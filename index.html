<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wire Runner</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1>Welcome to Wire Runner!</h1>
 
        <img src="wirerunner.gif"  id="wireRunner" height="150px"/> 

    <p style="text-align: center;">
        Here you will find your guide to and explanation of Over The Wire challenges. All commands are run from the Linux bash terminal. Please start with Bandit. The challenges and systems are in the order I believe they make sense. 
    </p>

    <button class="accordion">Bandit  +</button>
    <div class="panel">
        <button class="accordion">Bandit  0</button>
        <div class="panel">

            <p>
                For level 0 of over the wire we will just need to login. The details are given to us. The little dollar sign is a terminal character that means the command is being run as the user you are logged in as. Login using the following:
            </p>

            <pre class="codeBlocks">
                <code>
                $ ssh bandit0@bandit.labs.overthewire.org -p 2220 
                </code> 
            </pre>
            
            <p>
                What does all the above letter soup mean you wonder? Let's break it down!
            </p>

            <p>
                First with <strong>ssh</strong> we tell the computer. "Hey, you have this thing called <strong>S</strong>ecure <strong>SH</strong>ell. I want to use that command."
                <br/><br/>
                Then we say where we want to ssh to. You will see the next part kinda looks like an email? It can be interpreted in the same way. The first part before the <strong>@</strong> is the user we want to be. In this case bandit0. After the <strong>@</strong> is the domain we want to be at. In this case: bandit.labs.overthewire.org. Neat! <br/><br/>
                Lastly we have this weird <strong>-p 2220</strong> thing... what's that about? Long story short this specifies the network port you want to connect to. Web servers use ports to keep their services and communication streams separate.
             </p>
            <p>
                If you have never logged in to over the wire you will be prompted to accept a Key. Huh? What? Keys? <br/><br/>
                Basically what is happening here is. When you encrypt something you and the person you are talking to need to agree on how things will be encrypted. This key is part of the cipher you will need to encrypt things to securely talk to the server you are connecting to. <br/><br/>
                What does all this "The authenticity of host '[bandit.labs.overthewire.org]:2220 ([176.9.9.172]:2220)' can't be established." Mean? Well in the scary world of the internet we have some authorities that can validate that someone is who they say they are. This is just saying these authorities don't have a record for this key or who it belongs to. Rest assured though. You can accept this key. So just say yes.
            </p>
            <p>
                Next we will be prompted for the password to login with. Luckily they give this to you!
            </p>
            <pre class="codeBlocks">
                <code>
                bandit0  
                </code> 
            </pre>
            <p>
                Enter this password and you are now logged in as another user, on another computer, somewhere else completely on earth. That's insane!
            </p>
            <p>
                The next instructions are also given to you this early in the game. The next password is in a file called <strong>readme</strong> and we use that password to login to the next level. To read it use the <strong>cat</strong> command.
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat readme 
                </code> 
            </pre>

            <p>
                The <strong>cat</strong> command just reads some text and prints it out to the terminal for you to read. I still personally like to imagine that the floating cat head from Alice in wonderland is reading it to me.
            </p>
            <p>
                Copy this weird long looking password. Exit your connection session by typing:
            </p>
            <pre class="codeBlocks">
                <code>
                $ exit 
                </code> 
            </pre>
            <p>...into your terminal. And you should be back to your home terminal.</p>
            <p>Sweet! We did it. Now we can go on to the next level. Ready?</p>
        </div>

    
        <button class="accordion">Bandit  1</button>
        <div class="panel">
            <p>
                Now we are at our first challenge. here the password is stored in a file called: <strong>-</strong>
            </p>
            <p>
                Cool, we read a file last time... just use <cat>cat</cat>? Ah... doesn't work.. what gives?
            </p>
            <p>
                When cat sees the "-" it does not interpret this as a file name, it interprets it as another way to represent stdin (standard input, basically where your computer receives input from, no need to worry about this to much at the moment).
            </p>
            <p>
                Well how do we get around this? We would need to tell cat to interpret this as a file name. To do this we need to use a special character combination in Linux:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ./ 
                </code> 
            </pre>
            <p>
                Well that looks really weird... what does it do? In Linux this is a way to tell a command, or anything almost that "Hey, I want to look for or do this thing in the directory that we currently are." Directories are the same thing as folders in Windows.
            </p>

            <p>
                So to read the password file we would need to:
                <pre class="codeBlocks">
                    <code>
                    $ cat ./- 
                    </code> 
                </pre>
            </p>

            <p>
                Great! That was weird but not too hard. Ready for the next level? Let's go!
            </p>
        </div>


        <button class="accordion">Bandit 2</button>
        <div class="panel">
            <p>
                So our next machine needs us to open a file with spaces in it. Luckily this is super easy. 
            </p>
            <p>
                What makes opening a file with spaces different is that cat does not interpret the space as space character. It thinks you want to open another file. So:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat this file
                </code> 
            </pre>
            <p>
                Would be asking the computer to:<br>
                -cat the file: this<br>
                -cat the file: file<br>
                So the error we will get with this is telling us that the file name we put in to cat does not exist. As all of these treated as separate file names and are thus not valid names of things that we can cat.
            </p>
            <p>
                How do we get around this? There are two ways we can go about this
            </p>
            <p>
                Well we need to tell cat that the string of text we put in is the exact wording. And just as with english. We use quotes! So we need:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat "spaces in this filename"
                </code> 
            </pre>
            <p>
                Basically what this is saying is. Everything in the quotes is the exact words and formatting(spaces included) that I want.
            </p>
            <p>
                Another way we can do this is with back slashes. What these do is they escape the function of the character being fed to the terminal. So by default it would mean "Hey here is a space, so things after this character is considered a new file.". By escaping this meaning we can have the space be what we are use to it being in text files. So it would look like:
            </p>

            <pre class="codeBlocks">
                <code>
                $ cat spaces\ in\ this\ filename
                </code> 
            </pre>
            <p>
                Woah! That looks kinda funky! Do I need to remember how to format this? Luckily not! Linux has this super cool feature called tab complete.
            </p>
            <p>
                What tab complete does is search for files or folders in the directory that you are currently in and try and match the name as best as possible. So try typing:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat sp
                </code> 
            </pre>
            <p> 
                And now press tab. It will complete it all for you! Sweet! 
            </p>
            <p>
                Submitting the command one of these two ways will get you the next password and we are on our way to level 3!
            </p>
        </div>


        <button class="accordion">Bandit  3</button>
        <div class="panel">
            <p>
                Cool. Now we are in level 3. In this level our password is in a hidden file in a folder.
            </p>
            <p>
                First, let's find our folder. How do we do this in the text based terminal Matrix? We use the command: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ ls
                </code> 
            </pre>
            <p>
                Well... what does this do? Simple, it just <strong>L</strong>i<strong>S</strong>ts everything in the directory that you are currently in. We will then see a directory named: <i>inhere</i>
            </p>
            <p>
                Well how do we get into "inhere" We use this command:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cd inhere
                </code> 
            </pre>
            <p>
                This means <strong>C</strong>hange <strong>D</strong>irectory and is a command you will use so much that you will feel like a CD with only one song on it.
            </p>
            <p>
                New directory, new files and directories to find. <strong>ls</strong> time! What? Huh? ls didn't work? Or the directory is empty? Did I and over the wire just lie to you?
            </p>
            <p>
                Now we get to hidden files and folders. How do we see those? We use the command:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ls -la
                </code> 
            </pre>
            <p>
                This will list everything in a <strong>l</strong>ong format (gets you extra juicy details) and will list <strong>a</strong>ll of the files and directories. These can be spotted with the "." (dot) that the file or directory name starts with. In this case the file with the name "<i>.hidden</i>" .
            </p>
            <p>
                Why the naming convention? Not sure really. Someone just decided that's the way (ah-ha ah-ha) they like it.
            </p>
            <p>
                Anyway you can now just cat the hidden file (be sure to include the period in the name) and you can read the password for the next level.
            </p> 
            <pre class="codeBlocks">
                <code>
                $ cat .hidden
                </code> 
            </pre>

            <p>
                See you in the 4th dimension!
            </p>
        </div>


        <button class="accordion">Bandit  4</button>
        <div class="panel">
            <p>
                The next password is in the only human readable file in the "<i>inhere</i>" directory. What does that mean?
            </p>
            <p>
                Well anything that isn't really data files. That definition should be good enough for now.
                But to see what one looks like, after you <strong>cd</strong> into the inhere directory. Run an <strong>ls</strong> so that we can see all the files. let's open the first file. They are all dashed file names. Luckily we have also touched on these before. So run the command: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat ./-file00
                </code> 
            </pre>
            <p>
                What just happened to the terminal? That is a mess! Luckily to clear up this mess all we have to do is well.. clear it. Run this command:
            </p>
            <pre class="codeBlocks">
                <code>
                $ clear
                </code> 
            </pre>
            <p>
                That looks better. Well how do we find the file we want?
            </p>
            <p>
                Linux has this cool command called <strong>file</strong> we give it the name of a file we want to know the type of and it will tell us what the data in the file tells the program it is. (So if you make a text file, but change the extension to be .png, you won't be fooling file)
            </p>
            
            <p>
                So we gotta run file on all of these until we get the right one? I mean... you can, I won't stop you. Or... we can do this:
            </p>
            
            <pre class="codeBlocks">
                <code>
                $ file ./*
                </code> 
            </pre>
            
            <p>
                So we know what <strong>file</strong> does... and we know what <strong>./</strong> means.... what is the asterisk (<strong>*</strong>) doing? It is a wild card symbol. It is a way to tell the terminal match anything. I don't care what it is or what it is called, it is a match. So *.txt would mean all text files. *.mp3 would be all mp3s.  
            </p>
            <p>
                The above command is just saying use file on all things in this directory. You will see one of the files has a different file type. You can <strong>cat</strong> this file (remember how to cat things starting with a "-"? If not just scroll up to bandit 1). And we have the password for level 5. See you there!
            </p>
        </div>


        <button class="accordion">Bandit  5</button>
        <div class="panel">
            <p>
                So, we have made it to level 5 and now we get to start putting a lot of things together. In this challenge our file is one of many files in one of many folders, and has quite a few properties.
            </p>
            <p>
                It is human-readable, 1033 bytes in size and not executable. The only one we really care about is the file size. How are we going to find this file without going through each file and directory?
            </p>
            <p>
                Easy, Linux has a <strong>find</strong> command. Find works by default by starting from the directory you run it in and going down the directory tree. We can learn more about the command and its arguments by using the <strong>man</strong> command
                <pre class="codeBlocks">
                    <code>
                    $ man find
                    </code> 
                </pre>
                This will open a document that will explain the command and many of its potential uses and options to you. Enough about this though, let's get to finding that file!
            </p>
            <p>
                So we know we can use the <strong>find</strong> command and we have some details about the properties of the file we want to find, most notably its size. We can use this to narrow down the amount of files it could be. So let's run this from the home directory (not in any subdirectories such as any of the <i>maybehere</i> directories.)
            </p>
            <pre class="codeBlocks">
                <code>
                $ find -size 1033c
                </code> 
            </pre>
            <p>
                So the above command says we want to use find from where we are running the command in the directory tree and down, and we are looking for a file with the <strong>size</strong> of <strong>1033c</strong>. The <strong>c</strong> is to denote bytes.
            </p>
            <p>
                We will get one matching file. Now you can either <strong>cd</strong> to the directory the file is in, or copy the whole output of find and paste it after cat. So it will look like:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat ./inhere/maybehereXX/XXXX
                </code> 
            </pre>
            <p>
                I am omitting the correct path as not to spoil it.
            </p>
            <p>
                Grab that password and we are on to level 6!
            </p>
        </div>


        <button class="accordion">Bandit  6</button>
        <div class="panel">
            <p>
                This level is pretty much the same thing as the last one. We will use <strong>find</strong> again. With a few more parameters. Our file has a few properties again. It is <i>somewhere</i> on the server, meaning we would need to search the whole directory tree. It is owned by group 6 (We won't really be using this info). It has a size of 33 bytes.
            </p>
            <p>
                Sweet so from all that info we can do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ find / -size 33c -user bandit7 2>/dev/null
                </code> 
            </pre>
            <p>
                Looks kinda familiar... right? Let's look at what every part of that... incantation means. We have used <strong>find</strong> so we know what that does. What's the  <strong>/</strong> doing? Well remember when I said that find works by search from where you are and down the directory tree? Here we are telling find where to start from. The / is a way of declaring the root of the directory tree, so it will search through <i>everything</i>... the whole system. At least everything your user has permission to access. More on that in a bit.
            </p>
            <p>
                <strong>size</strong> we touched on, this just lets us specify how big the thing we want to find is.
            </p>
            <p>
                <strong>user</strong> is a new one. Not too hard to guess what it means though. It is just the name of the user that owns the file or directory.
            </p>
            <p>
                Now the weird one. What is this <strong>2>/dev/null</strong> thing? This is not a part of find. This lets us manipulate the output we will get from find. So remember when I said <i>"At least everything your user has permission to access."</i> When we use find it will tell us when it cannot access a certain directory because it does not have permission, it does this mainly to inform you that, "Hey, I couldn't look through this thing further, I'm just letting you know so that you can decide on what to do about that. Do you wanna give me permission? 'Cause your file might exist there.". This is where we get to the <strong>2</strong> this is a way to specify stderr (standard error). All outputs that are errors use this instead of stdout (standard out). No need to worry about what these are now. Basically the system just handles how it presents standard output and error output a little different, and we currently care about the errors to clean up our output. So 2 means error output. 
            </p>
            <p>
                Now we have the <strong>></strong>. This is a redirect. It is what we use to tell output from things where to go if we do not want to use the defaults.
            </p>
            <p>
                Then we have /dev/null . This is a directory path, no? Yes! Exactly we are redirecting it to what is essentially a black hole in Linux. Anything you send here will just vanish into the void.
            </p>
            <p>
                You can run the command without the 2>/dev/null, but that will fill up your screen. Let's run the one that does redirect again to get our less cluttered output.
            </p>
            <p>
                You should now see two results. We could use the <strong>-group bandit6</strong> flag here as well, but I think this level of "perfect" command is not needed, and we will touch on this more in level 7 and beyond.  You can either cat both or just the one, should be pretty clear by the file name which one it would be. Again you can either <strong>cd</strong> all the way to the directory that the file is in and <strong>cat</strong> it there or you can just <strong>cat</strong> it from where you are specifying the file path like this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat /XXX/XXX/XXX/XXX/xxx.obviousFileName
                </code> 
            </pre>
            <p>
                Again I left out the file path and name so that I don't make it too easy for you. Grab that password and we are on our way to lucky number 7.
            </p>
        </div>


        <button class="accordion">Bandit  7</button>
        <div class="panel">
            <p>
                Lucky number 7. Here we get into the minefield known as <strong>grep</strong>. Before we continue with that. This is where things  will start getting really weird and there will be multiple ways to do things and find the answer, this will just be what I did that was good enough. So now I want to stress the importance of not looking for a "perfect" answer. Grep and Regex have books written about them, and every language has it's own regex (regular expression) quirks. So again, do not worry about how to get a 100% correct answer that will only get you the password as output. Get something that is close enough, get the password and move on. Serious bit aside. Let's get started. Luckily the grep in this level is still pretty easy.
            </p>
            <p>
                So what is grep and why is it so terrifying? GREP stands for Global Regular Expression Printer. What does this mean? What is a Regular Expression? A regular expression is a string of letters and symbols we can define so that we can match words in a text file. So I can use GREP to find the string of letters "cat" in a file of my choice, and every time I talk about cats (which is a lot), grep will return that instance of the word. Doesn't sound too hard, and that concept isn't. Where grep gets wild is we can use it to search for things that aren't explicit words. I can tell grep something like: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ grep -e [0-9][a-z][dD]f myfile.txt
                </code> 
            </pre>
            <p>
                Yeah.... what? How is that even a thing? What does that even mean? Let's take it piece by piece.
            </p>
            <p>
                First we just have the command <strong>grep</strong>, which is just asking the terminal to use the command grep in all of its goodness.
            </p>
            <p>
                Next we have <strong>-e</strong>. This lets grep know that whatever is following is the expression we want to use. The expression can also be put in single or double quotes. so: "expression" or 'expression', but I have seen instances where how different terminals interpret single or double quotes have had some weird results. So I tend to stick with <strong>-e</strong>, but you do you.
            </p>
            <p>
                Now we have out expression <strong>[0-9][a-z][dD]f</strong>. What this is saying is:<br>
                -<strong>[0-9]</strong> in the first position of the string (word) we have anything from the number 0 - 9. So it can be any single digit number.<br>
                -<strong>[a-z]</strong> in the second position we have any lower case letter in the range a - z. So the whole lower case alphabet.<br>
                -<strong>[dD]</strong> This says in the third position we can have either a lower or upper case d.<br>
                -<strong>f</strong> in the last position we have the letter f.<br>
            </p>
            <p>
                So a few strings that would match that search query would be:<br>
                - 0qDf<br>
                - 9zdf<br>
                - 7bdf<br>
            </p>
            <p>
                Wow, that... was a lot and we haven't even done anything with bandit. But now that you have a very basic idea of grep and how it can be a text based super power. We can work on the challenge.
            </p>
            <p>
                Our password is stored in a file <i>data.txt</i> and is next to the word <i>millionth</i>. So using <strong>grep</strong> we can find that pretty easily. Since grep will match the searched string (word) and print out the line the password is in. So if we do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ grep -e millionth data.txt
                </code> 
            </pre>
            <p>
                We will get one line of output that has the password. Grab that and I will catch you on the 8th floor where grep, regex and everything will get weirder.
            </p>
        </div>


        <button class="accordion">Bandit  8</button>
        <div class="panel">
            <p>
                In this challenge our password is stored in <i>data.txt</i> and is the only line that appears only once. So let's <strong>cat</strong> that file and see what we have to work with.
            </p>
            <p>
                Yikes. That looks messy. How can we clean it up so that we get what we want?
            </p>
            <p>
                We can do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat data.txt | sort | uniq -c
                </code> 
            </pre>
            <p>
                Well, some of that looks familiar some of it does not. Let's take it step by step.
            </p>
            <p>
                <strong>cat</strong> just reads the file we give it as input.
            </p>
            <p>
                Then we have this thing: <strong>|</strong>. What's this? This is a pipe. What it does is take the output from the command on the left of it and feeds it as input to the command on the right. So instead of cat's output going to the screen we send it to the next command <strong>sort</strong>.
            </p>
            <p>
                So now we can talk about <strong>sort</strong>. What <strong>sort</strong> is doing here is reading the whole document. Looking for lines that are exactly the same and rearranges them so that they are one after another. 
            </p>
            <p>
                Then we pipe it again to the next command <strong>uniq -c</strong>. What uniq does is look for lines that are exactly the same and then omits all but one of them. Important here is that <strong>uniq</strong> has to be run after <strong>sort</strong> because uniq will only omit duplicate lines that occur after each other. Lastly we have <strong>-c</strong>, All this does is show a count for each line, how many times it occurred in the document. 
            </p>
            <p>
                Look for the only string that occurs just once based on the count on the left. Grab that and I will meet you in level 9.
            </p>
        </div>


        <button class="accordion">Bandit  9</button>
        <div class="panel">
            <p>
                This time our password is in the <i>data.txt</i> and is one of the few human-readable strings, preceded by several ‘=’ characters.
            </p>
            <p>
                Cool so just: grep -e == data.txt (two == at least since we know it is multiple equals signs.)
            </p>
            <p>
                Uhm... what? What does "Binary file data.txt matches" mean? From the grep man pages we can see "Normally, if the first few bytes of a file indicate that the file contains binary data, grep outputs only a message saying that the file matches the pattern" Since our file starts with binary we get this output. So what do we do?
            </p>
            <p>
                We can do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ grep -a -e == data.txt
                </code> 
            </pre>
            <p>
                We should know what most of that does. Just the <strong>-a</strong> is new. This will let grep treat the binary as if it is text. But this output is very messy. You can still see the password, grab it and go or.... We could do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ strings data.txt | grep -e ==
                </code> 
            </pre>
            <p>
                The only new command here is <strong>strings</strong> and basically all it does is print only all the text characters in a document. So none of the binary noise.
            </p>
            <p>
                There are many lines of output here. Only one of them has the same format as the passwords we have been using. Copy it and I will catch you in our first double digit challenge! 
            </p>
        </div>


        <button class="accordion">Bandit  10</button>
        <div class="panel">
            <p>
                I am going to be honest with you here. This level feels like a downtick in difficulty. The password is stored in the <i>data.txt</i> file and the whole file is base64 encoded. What is base64? In short and very basically put, it is a way for us to represent binary data to an ASCII string.
            </p>
            <p>
                Base64 is so popular that Linux has a built in command for working with it: <strong>base64</strong>. Reading through the man page will get us more info on what we can do with it. But we really just care about <strong>--decode</strong>. So:
            </p>
            <pre class="codeBlocks">
                <code>
                $ base64 --decode data.txt
                </code> 
            </pre>
            <p>
                Here we are saying we want to use base64, we want to use the decode functionality and we want to use it on the data.txt file. Pretty simple.
            </p>
            <p>
                Grab that password and I will see you in the next level.
            </p>
        </div>

        <button class="accordion">Bandit  11</button>
        <div class="panel">
            <p>
                Here is another one where we can kind of be lazy. Or at least, there are very easy ways of doing this.</p>
            <p>
                Our password is stored in the <i>data.txt</i> file and all upper and lowercase letters have been rotated 13 positions. Basically the alphabet now starts from n and goes all the way around back to m as the last letter. We are replacing the letters of the alphabet with the 13th letter after it in the alphabet.
            </p>
            <p>
                What makes this pretty simple is there are many decoders for this online. So a quick Google search for a ROT-13 decoder will get us a webpage where we can paste the text in and get our answer. Do that, get the answer and we can go to level 12.
            </p>
            <p>
                If you really want to know how to do something like this in the terminal:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat data.txt | tr [a-z] [n-za-m] |tr [A-Z] [N-ZA-M]
                </code> 
            </pre>
            <p>
                Let's break down what this is saying:
            </p>
            <p>
                <strong>cat</strong> will read the file and push it through to <strong>tr</strong> command (translate).
            </p>
            <p>
                Then we say: hey translate command (tr). I want to use this character set <strong>[a-z]</strong> and I want you to shift it so that it would work like <strong>[n-za-m]</strong> (the 14th letter of the alphabet to the 26th and then the 1st to the 13th), all only in lower case.
            </p>
            <p>
                All of this is the: <strong>tr [a-z] [n-za-m]</strong>
            </p>
            <p>
                We then take what that output would be and push it through to translate again, and do the same thing, but with upper case characters.That is the:
                <strong>tr [A-Z] [N-ZA-M]</strong>. After which you will have your answer.This is also a very verbose way of going through it, but it can help keep your logic and readability clear.
            </p>
            <p>
                A much more condensed version of the command would be:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat data.txt | tr [a-zA-Z] [n-za-mN-ZA-M]
                </code> 
            </pre>
            <p>
                Which does the same thing, we just give it both data sets and translation sets at once. Get the password and I will see you in level 12.
            </p>
        </div>

        <button class="accordion">Bandit  12</button>
        <div class="panel">
            <p>
                Now, this one... is a jump in difficulty. It also just has a lot for us to do, so it will take a minute. 
            </p>
            <p>
                So first they tell us. To do this box we should create a directory under /tmp in which you can work using mkdir. Why? Well because the file we are working with is a hex dump and has then been compressed multiple times. So using a copy of the file just seems like a really good idea since we might break or corrupt something.
            </p>
            <p>
                What is a hex dump? A hex dump is a snapshot of what was in the computers memory. So in this case, a memory dump of what was the compressed file. 
            </p>
            <p>
                But first that copy... how will we do that? Well with this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mkdir /tmp/wireRunner
                </code> 
            </pre>
            <p>
                The <strong>mkdir</strong> means <i>make directory</i> and the <strong>/tmp/wireRunner</strong> specifies the absolute path, from root, of where we want the file to be made as well as its name. If you do not do it this way, you will probably just get a permission denied error from the bandit box. Just replace wireRunner with your name. 
            </p>
            <p>
                Then we copy the file with the <strong>cp</strong> command. We specify first what we want to copy and then where we want to copy it to:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cp data.txt /tmp/wireRunner
                </code> 
            </pre>

            <p>
                Now we just <strong>cd</strong> to <strong>/tmp/wireRunner</strong> and we can get started!
            </p>
            <p>
                Cool, so how can we work with and interact with this hex file? Linux has a command <strong>xxd</strong>. Which can be used to create or reverse hex dumps. So we need to do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat data.txt | xxd -r > data
                </code> 
            </pre>
            <p>
                So by now, some of that should make sense. <strong>cat</strong> reads the file and we pipe it to our <strong>xxd</strong> command. The <strong>-r</strong> tells xxd to reverse the hex dump and then lastly we redirect its output to a new file called <i>data</i> with <strong>> data</strong>.
            </p>
            <p>
                Now we run <strong>file</strong> on the <i>data</i> file we got as output and it will tell us that this file is gzip compressed data. Gzip files have an extension of <strong>.gz</strong>. So we can rename the file and decompress it. How do we rename?
                With the <strong>mv</strong> command. This command is used to move files, but can also be used to rename them.
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data data.gz
                </code> 
            </pre>
            <p>
                The above command is saying move (<strong>mv</strong>) the <i>data</i> file in our current directory to our current directory and then call it <i>data.gz</i>. Weird thing to wrap your head around I know. You are just moving the file to the exact same place and then just renaming it.
            </p>
            <p>
                Now that it has the .gz extension we can interact with it with the <strong>gzip</strong> command and use its <strong>-d</strong> (decompress) flag to get the data decompressed.
            </p>
            <pre class="codeBlocks">
                <code>
                $ gzip -d data.gz
                </code> 
            </pre>
            <p>
                Now we have a data file again, we can see this with <strong>ls</strong>. So lets <strong>file</strong> it again to see what we are working with. Ahh.. a bzip2 file. These have the extension of <strong>.bz</strong>. We will need to rename it and then decompress it. This will be the theme until the file is ascii text again. Yay?
            </p>
            <p>
                So move to rename:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data data.bz
                </code> 
            </pre>
            <p>
                Now that we have the <strong>.bz</strong> how do we unzip it? If we look at the man page for bzip2, we can see that there is a bunzip2. Lets try that:
            </p>
            <pre class="codeBlocks">
                <code>
                $ bunzip2 data.bz
                </code> 
            </pre>
            <p>
                We have a data file again. <strong>file</strong> time. It is a gzip again. So move to rename with the <strong>mv</strong> command and give it the .gz extension. Then decompress with the <strong>gzip -d</strong>. Another data file. Run <strong>file</strong> on it and we have a... Oh? What is a posix tar archive? Just another compression standard, no need to worry about it too much. What is its extension? Just <strong>.tar</strong>
            </p>
            <p>
                So move to rename:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data data.tar
                </code> 
            </pre>
            <p>
                Now we need to decompress it again:
            </p>
            <pre class="codeBlocks">
                <code>
                $ tar -xf data.tar
                </code> 
            </pre>
            <p>
                <strong>tar</strong> uses the tar command and the <strong>-xf</strong> extracts the file archive.
            </p>
            <p>
                Now if we <strong>ls</strong> we have a.. <i>data5.bin</i>? The <i>data.tar</i> is also still there. I mean ok.. sure. Lets file the data5.bin. Another .tar? Yep. So move to rename:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data5.bin data.tar
                </code> 
            </pre>
            <p>
                What? We are renaming it with a name that already exists? Yep. In Linux this will not give you an error. It will just over write the file and since we are done with the previous <i>data.tar</i> we can do this.
            </p>
            <p>Another <strong>tar -xf data.tar</strong> time.</p>
            <p>
                This time we get <i>data6.bin</i>. Man this has been going on a while.... I promise we are almost done. <strong>file</strong> <i>data6.bin</i> and we have another bzip2. Rename and decompress time again. <strong>.bz</strong> extension and the bunzip2 command time. 
            </p>
            <p>
                A new data file. <strong>file</strong> command. Another tar. Rename to a <strong>.tar</strong> and then <strong>tar -xf</strong> time
            </p>
            <p>
                Now we have <i>data8.bin</i> was a gzip file. You guessed it. Rename to <strong>.gz</strong> and <strong>gzip -d</strong>.
            </p>
            <p>
                <strong>file</strong> our data file again and.... oh my.... It is actually an ASCII file this time. We did it! We got through all this and now we finally have our password! Grab it and we are on to level 13 that shouldn't be this tedious again.
            </p>
        </div>

        <button class="accordion">Bandit 13</button>
        <div class="panel">
            <p>
                So in this level we know what file the password is kept in. But it can only be read by user <i>Bandit 14</i>. Well how can we read it as user 13? We get a private SSH Key that we can use to log in to the bandit14 user. 
            </p>
            <p>
                We can use <strong>ls</strong> to see the file is in our home directory. Awesome! How do we use it?
            </p>
            <p>
                Like this:
            </p> 
            <pre class="codeBlocks">
                <code>
                $ ssh bandit14@localhost -i sshkey.private
                </code> 
            </pre>
            <p>
                Sweet, most of that looks familiar by now. Just two new things.
            </p>
            <p>
                <strong>localhost</strong> is just a way to refer to the system you are currently working on.
            </p>
            <p>
                <strong>-i</strong> lets you choose a file that validates your identity.
            </p>
            <p>
                Awesome now we just need to get to that file in <i>/etc/bandit_pass</i> and then <strong>cat</strong> the <i>bandit14</i> file and we have the password!
            </p>
            <p>
                See you in level 14!
            </p>
        </div>
    
        <button class="accordion">Bandit 14</button>
        <div class="panel">
            <p>
                Welcome to level 14. You have 2 options on how to proceed. If you are still logged on to bandit14 from the last level. Great! We can just continue. If not just ssh back into it and we can get going.
            </p>
            <p>
                So here we are told we can get the password for <i>bandit15</i> by submitting the password for <i>bandit14</i> to port <i>30000</i> of the localhost.
            </p>
            <p>
                That is a mouthful. Basically it is saying that we need to send information to a server that is set up on our localhost. This is doable with a command <strong>nc</strong> (netcat) to connect locally. netcat is a unix utility that sends and receives data across network connections. Including ones on our local machine. So we just have to give the password for  level 14 to this port on our local machine and it will return the password for level 15.  
            </p>
            <p>
                This should do the trick:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e" | nc localhost 30000
                </code> 
            </pre>
            <p>
                <strong>echo</strong> literally just copies back as output what you gave it as input. The pipe symbol we have worked with. It takes output from the left and feeds it as input to the right. Then <strong>nc</strong> lets us use the network connection on <i>localhost</i> on port <i>30000</i>. You will then get the password for level 15 and we are on our way again!
            </p>
        </div>

        <button class="accordion">Bandit 15</button>
        <div class="panel">
            <p>
                So things are getting harder and we might tend to start using commands or technologies that you can spend a lot of time on. We will only be touching on the very basic for what we need for the solution. If you ever feel like you want to spend more time investigating these technologies, please do. Just know that you can spend weeks and still not know everything you want. Google is your friend here. 
            </p>
            <p>
                Why the speech? We are going to use <strong>openSSL</strong>. This lets us use TLS protocols for secure connections and communications in computer networks. TLS is a set of cryptographic protocols. Yes these descriptions are pretty vague. I believe it is all we need. It gives us enough to have utility. Basically openSSL is a technology that lets us encrypt our connections. You know when your web browser says httpS vs just http? This is what provides the S (secure). 
            </p>
            <p>
                Our challenge states we can get our password for <i>bandit16</i> by submitting the <i>password</i> for <i>bandit15</i> to port <i>30001</i> to the local machine with ssl encryption.
            </p>
            <p>
                Mouthful again. Basically we just need to use an ssl connection (<strong>openssl</strong> can do this) to connect to a different port on the machine we are currently using and submit the password of the current level as input.
            </p>
            <p>
                How?
            </p>
            <p>
                Like this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "BfMYroe26WYalil77FoDi9qh59eK5xNr" | openssl s_client -connect localhost:30001 -ign_eof
                </code> 
            </pre>
            <p>
                Sweet, the only really new thing here is the <strong>openssl</strong> stuff. The echo and pipe we have touched on in the last challenge. 
            </p>
            <p>
                <strong>openssl</strong> just says we want to use the openssl command
            </p>
            <p>
                <strong>s_client</strong> creates a generic ssl/tls client that we can use to connect to a server that is running ssl/tls to communicate. This is what allows us to connect to the secure server. This is only used for testing however.
            </p>
            <p>
                <strong>-connect localhost:30001</strong>. This tells openssl where we want to connect to and on which port.
            </p>
            <p>
                <strong>-ign_eof</strong> all this is doing is keeps the communication stream open after it has been established. Why do we need this? When setting up the connection we get a whole bunch of info back from the ssl/tls server. After this information is received the connection appears to close before we can send our information from echo so that we can get the password for bandit16. As a side note you can omit some of the extra output with <strong>-quiet</strong>. You will just lessen the amount of output. The password will still appear at the bottom of your output.
            </p>
            <p>
                Grab that password and get ready for more weirdness.
            </p>
        </div>

        <button class="accordion">Bandit 16</button>
        <div class="panel">
            <p>
                Not gonna lie, another funny one. It combines some things we have done before, but also requires us to use new tools. Most notably <strong>nmap</strong>. But I am getting ahead of myself. Here our password can be retrieved by submitting the password of the current level to a ssl server on a port in the range 31000 to 32000 on our local machine. Only one of these will give us the password. How can we narrow this down? 
            </p>
            <p>
                Meet one of your best friends in the world of networking, info-sec and administration. <strong>nmap</strong>. It is a network mapper. You will use it to see which IPs are up, what ports are open and what services they run. It is honestly worth investing time into learning this beautiful tool. We will not be going that in-depth with it here though. So what we want with nmap is:
            </p>
            <pre class="codeBlocks">
                <code>
                $ nmap -sV localhost -p31000-32000 | grep -e ssl
                </code> 
            </pre>
            <p>
                So that is just saying we want to use <strong>nmap</strong>. With <strong>-sV</strong> we are telling nmap to do a detailed scan on the ports and what services they may be running. Then we say the device we want to scan, in this case <strong>localhost</strong> (which we know means the machine we are working on). And then the ports we want to scan. This is declared with the <strong>-p31000-32000</strong>. This will take a moment to scan. So get up, get some water.. maybe a good stretch? It is good for you.
            </p>
            <p>
                We then pipe the output to <strong>grep</strong> and only look for the pattern ssl with: <strong>grep -e ssl</strong>. We know we are looking for an ssl service and nmap will report this back to us if it is running on a port. grep is just removing a lot of noise from the nmap output. If you have the time, or you just want to, you can run this without grep and look at everything you get. This is why grep is so nice and so powerful. 
            </p>
            <p>
                Great now with just the two possible ports our job has gotten a lot easier. One of these is running an ssl/echo service and the other is an ssl/unknown. I'm gonna go ahead and guess that the ssl/echo is just gonna send back what we send it. So let us try the other port:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "cluFn7wTiGryunymYOu4RcffSxQluehd" | openssl s_client -connect localhost:31790 -ign_eof
                </code> 
            </pre>
            <p>
                Cool. Here we echo the password into the connection. We use openssl with s_client to say we want to be the client side of things. (Remember this from the last level?). We tell openssl where we want to connect to. In this case the port we found with nmap (<strong>31790</strong>) and we use our <strong>-ign_epf</strong> to keep that connection open... 
            </p>
            <p>
                Ok what gives? We don't get a password. Should we try the other port? Nope. We get the RSA private key. A few levels ago we use a private key to connect to another user on the same machine. So let us save this private key in a file so we can use it to authenticate as user bandit17.
            </p>
            <p>
                Copy everything including the begin and end private key parts. It is a lot yes. Now where to save it? If you recall when we worked on the decompression issue we cannot just create files anywhere on bandit. We can only use <strong>/tmp</strong>.
            </p>
            <p>
                Make another folder in tmp with:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mkdir /tmp/rsaWireRunner
                </code> 
            </pre>
            <p>
                All of that should make sense at this point. But as a quick reminder. <strong>mkdir</strong> means make directory. Then we give it the path as well as the directory we want to make with <strong>/tmp/rsaWireRunner</strong>. Just use your own directory name. (Not rsaWireRunner). 
            </p>
            <p>
                Cool the directory exists. Now we cd to it. Once in the directory we can create the file we want. We can do this with:
            </p>
            <pre class="codeBlocks">
                <code>
                $ vim rsaKey
                </code> 
            </pre>
            <p>
                This will create the file named <strong>rsaKey</strong> and open it in the vim editor. If you have never used vim, it is a weird text editor, but a great one. To start being able to type something or paste something, first press <strong>i</strong> to insert. Now you can paste the copied key with <strong>right click and paste</strong> or with <strong>ctrl+shift+v</strong>. Sweet. Now to save and quit. First press <strong>Esc</strong> to exit insert mode. Then press <strong>:</strong> so that you can enter new commands. Then you enter <strong>wq</strong> (this will appear at the bottom left of your screen after the colon).
            </p>
            <p>
                And you are out of there with the file you need. 
            </p>
            <p>
                Now we need to use this to authenticate ourself as bandit17. However... there is an issue if you try it as is. This key file is too accessible to users on this device. The <strong>ssh</strong> command will pick up on this and tell you it is ignoring the file. So we need to change it so that the file is more private and ssh can be satisfied. So we use:
            </p>
            <pre class="codeBlocks">
                <code>
                $ chmod 400 rsaKey
                </code> 
            </pre>
            <p>
                What is this? In short we use <strong>chmod</strong> to change file permissions. The <strong>400</strong> means only root users can read and execute the file (this will keep ssh happy) and <strong>rsaKey</strong> is the file we want to change the permissions of. Sweet now we can: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ ssh -i rsaKey bandit17@localhost
                </code> 
            </pre>
            <p>
                Sweet. We are finally in bandit17. You can stay here and move on to bandit 18. Or you can take a stretch and water break and come back. In that case we are going to want to save the password for bandit 17. We can find it here:
            </p>
            
            <pre class="codeBlocks">
                <code>
                $ cat /etc/bandit_pass/bandit17
                </code> 
            </pre>
            <p>
                Save that somewhere and we are on our way. 
            </p>
        </div>
        
        <button class="accordion">Bandit 17</button>
        <div class="panel">
            <p>
                Bandit 17 is a bit of a dip in difficulty again. We have 2 files. <i>passwords.new</i> and <i>passwords.old</i> and the password is the only line that has been changed between the two. How can we find this?
            </p>
            <pre class="codeBlocks">
                <code>
                $ diff password.old password.new
                </code> 
            </pre>
            <p>
                Cool, <strong>diff</strong> just takes two files, compares them and then tells you what lines are different. Simple enough. Only not here would be that the order matters. The first files different lines will be the top output. The second files different line will be the bottom output. So if you put <i>.old</i> first you want the bottom password. If you put <i>.new</i> first you want the top line.
            </p>
            <p>
                Well that was... oddly easy. See you in Bandit 18.
            </p>
        </div>

        <button class="accordion">Bandit 18</button>
        <div class="panel">
            <p>
                Ok, I am not gonna lie here. This challenge is weird. To be able to log in you need to be in one of the bandit machines already, if you are still in 17 sweet! If not you can log back in to bandit0 as that is the easiest to do in my opinion, just <strong>bandit0</strong> with password <strong>bandit0</strong>
            </p>
            <p>
                Cool so now the basic:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ssh bandit18@bandit.labs.overthewire.org -p 2220
                </code> 
            </pre>
            <p>
                Uhm.. It says goodbye then kicks us out. What gives. As stated in the challenge on the website, someone modified the .bashrc file to close ssh connections. How do we go about getting a connection then? 
            </p>
            <p>
                We will need to look a little closer at <strong>ssh</strong> and its options.
            </p>
            <p>
                The configuration in the .bashrc is telling ssh to close the <i>pseudo-terminal</i> that <strong>ssh</strong> requests and creates. What is that? A terminal that has the functions of a physical terminal without actually being one. Basically it is part of what makes this whole ssh things work. We "fake" the terminal on our end and it sends its data to the terminal on the actual devices side.
            </p>
            <p>
                We need to force this to open. With ssh we can force this to happen by using <strong>-t</strong>. From the ssh man page : <i>Force pseudo-terminal allocation.  This can be used to execute arbitrary screen-based programs on a remote machine, which can be very useful, e.g. when implementing menu services.</i>
            </p>
            <p>
                And then we need to tell it what terminal to emulate, we can do this with: <strong>/bin/sh</strong>. In short this means in the <i>binaries</i> directory, use the binaries needed to give me a <strong>sh</strong>ell.
            </p>
            <p>
                All of that means we do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ssh -t bandit18@localhost /bin/sh
                </code> 
            </pre>
            <p>
                Now we are in a terminal that just shows a <strong>$</strong>. We can verify that we are bandit18 by using the command <strong>whoami</strong>. Use an <strong>ls</strong>, we see we have a readme. <strong>cat</strong> it and we have the password for 19. Awesome! Well that was a bit, and maybe a lil weird. Re-reading and re-doing this part will not be a bad thing. See you in 19!
            </p>
        </div>

        <button class="accordion">Bandit 19</button>
        <div class="panel">
            <p>
                This level is a bit easier. Here we get an executable called <i>bandit20-do</i>. To run it we need to put a <strong>./</strong> before it. Let's run it to see what it does:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ./bandit20-do
                </code> 
            </pre>
            <p>
                This is telling us we can use this program to run a command as user bandit20. Sweet, so we can use this to read the password for bandit20
            </p>
            <p>
                As we have learnt in other levels we can find passwords in <i>/etc/bandit_pass/</i>
            </p>
            <p>
                <strong>cat</strong> the file for bandit20 and we can move on to bandit20! 
            </p>
        </div>

        <button class="accordion">Bandit 20</button>
        <div class="panel">
            <p>
                In this level we are given a binary file <i>suconnect</i>. What this does is make a connection to a port on the local machine (that we specify). Reads a line of text from that connection and if it matches the expected input (in this case the password for level 20). We will get back the password for level 21.
            </p>
            <p>
                Ok... How do we set up this port? With <strong>nc</strong> otherwise known as netcat. This is another tool you would want to get really familiar with. It allows you to make network connections for all kinds of reasons. We will be using it here to set up a server that listens on a port. With something like <strong>nc localhost 30000</strong>. But wait, we also need to get the suconnect executable to read a string on the server we setup, how will we give the server this string to represent?
            </p>
            <p>
                We can echo that string to the server when we create it. <strong>echo "string"</strong>
            </p>
            <p>
                All of this means we want to do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "GbKksEFF4yrVs6il55v6gwY5aVje5f0j" | nc -l localhost -p 30000 &
                </code> 
            </pre>
            <p>
                Here <strong>echo</strong> will set the password for level 20 as a string in the server we will set up with <strong>nc</strong>. <strong>nc -l localhost -p 30000</strong>. This creates the server on the <i>localhost</i> on port <i>30000</i>. Any port number above 30000 and below 65000 should be fine to use here. Lastly the <strong>&</strong> tells the terminal to execute this command in the background. This will let us get our terminal prompt back so that we can run the executable.
            </p>
            <p>
                We then run:
            </p>
            <pre class="codeBlocks">
                <code>
                    ./suconnect 30000
                </code>
            </pre>
            <p>
                This will run the binary to the port we tell it to and it will then give us the password for bandit 21. Copy it and let's go!
            </p>
        </div>

        <button class="accordion">Bandit 21</button>
        <div class="panel">
            <p>
                In this level we get a little taste of automation. We have a program that runs at regular intervals that is doing something that we can use to get the next level's password. We can look in <i>/etc/cron.d/</i> to find and read this file to see what it does.  
            </p>
            <p>
                An <strong>ls</strong> in that directory will get us a file named: <i>cronjob_bandit22</i>. Well, what is this cron word that we keep seeing? It is a program we use in Linux to schedule things we want the system to do. So if every time you start up the system you want it to launch a few programs, make a few internet connections or anything really. You can create a <strong>cronjob</strong> to do this. So:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cd /etc/cron.d/

                $ cat cronjob_bandit22
                </code> 
            </pre>
            <p>
                This output tells us it is executing a file located in <i>/usr/bin/cronjob_bandit22.sh</i>. Let's <strong>cat</strong> that file and see what it is doing.
            </p>
            <p>
                Ok, this is creating a file in <i>/tmp</i> called <i>t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv</i> with permissions that means we can read it (<strong>chmod 644</strong>, we have not touched on chmod yet, but this basically means anyone can read this file). After it has created this file, it reads the file: <i>/etc/bandit_pass/bandit22</i> and redirects its output (with the <strong>></strong>) to the file it created int he previous step. If we read that file we can then get the password to bandit22
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgv
                </code> 
            </pre>
            <p>
                Sweet, got it. On to 22!
            </p>
        </div>

        <button class="accordion">Bandit 22</button>
        <div class="panel">
            <p>
                This level is roughly the same as the last one. We have another script that runs at certain time intervals and we need to read it to see what it does so that we can get the password for the next level. Let's go read that file.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cd /etc/cron.d/

                    $ cat cronjob_bandit23
                </code>
            </pre>
            <p>
                Ok this is running a script <i>/usr/bin/cronjob_bandit23.sh</i>. Lets <strong>cat</strong> to read it and see what we have.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat /usr/bin/cronjob_bandit23.sh
                </code>
            </pre>
            <p>
                Quite a bit going on here. In short what this script is doing is finding the password file for our current user and then outputs it to a new file with a name that comes from running the string "Iamuserbandit22" through an md5 hash. No need to worry about this too much. If we run the file we will get the name of the output file.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ /usr/bin/cronjob_bandit23.sh
                </code>
            </pre>
            <p>
                The above will just run the file. The output will then tell us that it is "copying passwordfile /etc/bandit_pass/bandit22 to /tmp/8169b67bd894ddbb4412f91573b38db3"
            </p>
            <p>
                <strong>cat</strong> that and we will have the password for bandit23. We didn't go to deep into reading and understanding each line of the bash script. That is another thing that is a course on its own. Maybe we will make a tutorial for that beast some day. See you in bandit 23!
            </p>
        </div>
        <button class="accordion">Bandit 23</button>
        <div class="panel">
            <p>
                So here we will need to write our first bash script. Exiting! Anyway we have another scheduled job that we need to figure out what it does and how we can use it to get the password for bandit 24. Lets go look at that file:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cd /etc/cron.d/
                    
                    $ cat cronjob_bandit24
                </code>
            </pre>
            <p>
                Another pretty big file.... What this script is doing is executing all scripts that are in the <i>/var/spool/$myname</i>. <strong>$myname</strong> is a variable and we want it to be the user we want to execute the script.
            </p>
            <p>
                Sweet lets make that script. First lets create folder that we can work in:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ mkdir /tmp/wireScript
                </code>
            </pre>
            <p>
                We know from previous bandits that we can make a directory in the tmp dir on the system so this is where we will put the password once we get it. <strong>cd</strong> into this directory (btw use your own directory and file names, mine are just examples) and make a file called password.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ touch password
                </code>
            </pre>
            <p>
                The touch command will make an empty file. Next we need to change permissions to this password file so that any user can write information to it (we will need bandit 24 to be able to write to this file).
            </p>
            <pre class="codeBlocks">
                <code>
                    $ chmod 666 password
                </code>
            </pre>
            <p>
                Finally script time! Do not worry it will not be as hardcore of a script. <strong>cd</strong> to <i>/var/spool/bandit24/</i> and we will make this script here. <strong>vim script.sh</strong> will make this file and open it for us to edit. The <strong>.sh</strong> extensions tells the system that it is a bash shell script. In the script we want:
            </p>
            <pre class="codeBlocks">
                <code>
                    #!/bin/bash

                    cat /etc/bandit_pass/bandit24 > /tmp/wireScript/password
                </code>
            </pre>
            <p>
                Write and quit out of vim. The <strong>#!/bin/bash</strong> tells your terminal what program to interpret the script with. The whole <strong>cat /etc/bandit_pass/bandit24 > /tmp/wireScript/password</strong> should make sense by now.
            </p>
            <p>
                When the script has been made you will quickly need to run:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ chmod 777 script.sh
                </code>
            </pre>
            <p>
                this will allow the script to be executed by user <i>bandit24</i>. Wait a few seconds and if you <strong>cat</strong> the password file in your /tmp/wireScript/ directory, you will have the password for bandit 24! That was fun right? A lot, but fun! See you in bandit 24.
            </p>
        </div>

        <button class="accordion">Bandit 24</button>
        <div class="panel">
            <p>
                Our password here will be given to us if we provide the password for <i>bandit 24</i> to port <i>30002</i> along with a 4 digit pin. This pin cannot be retrieved, it can only be guessed. Now, if you really want to and have nothing better to do you can manually type in every thing from 0000  to 9999. Retyping that command 10000 times seems like a crazy kind of hell. OR. We could write a script and make the computer do it for us. I like the sound of that option better. So let's make a bash script!
            </p>
            <p>
                First we make a directory to work in:
            </p>
            <pre class="codeBlocks">
                <code>
                    mkdir /tmp/wireBrute
                </code>
            </pre>
            <p>
                We know we can make folders in <i>/tmp</i>. Call it what you want. I just chose the word Brute since this kind of thing is known as brute forcing (where you guess every possible value 'till you get the right one.) <strong>cd</strong> into your dir and then <strong>vim brute.sh</strong> to create and open your shell script file. (if you know other languages feel free to use them. This guide will be using bash scripting)
            </p>
            <p>
                <span style="text-decoration: underline;"><strong>NOTE:</strong></span><br> The things after # are comments (except #!/bin/bash, we covered what this does in the last bandit level) that are used to just explain the code, they can be ignored and omitted from your script. It is however good practice to comment your code, it allows others and your future self to understand what you were doing if and when you need to troubleshoot something.
            </p>
            <p>
                Our script will be:
            </p>

            <pre class="codeBlocks">
                <code>
                    #!/bin/bash

                    #The bellow line creates a variable password and assigns the password of bandit24 as its value
                    password=UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ

                    #The for here creates a loop that will do some thing FOR every value in a set range
                    #The i declares a variable that we want to assign the value in the range to as the loop is occurring (i for integer)
                    #in {0000..9999} is the range we want. In this case all possible 4 digit values

                    for i in {0000..9999}
                    do #this do starts the loop
                    <span style="visibility: hidden;">aa</span> echo $password $i #this tells the script to echo out the value of the two variables password and i. Variables are denoted with the '$'
                    done #this ends the loop when completed
                </code>
            </pre>
            <p>
                That is quite a bit. Feel good that you wrote such a script. No need to worry about being a bash wizard. You will always be able to look for code snippets or examples online. Searching for a 4 digit counter in bash should get you something akin to that code. Feel free to try searching for a 4 digit counter in any other programming language that interests you and see if you can do it with that! Best way to learn. 
            </p>
            <p>
                Now we just need to execute the script and send it to the port:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ./brute.sh | nc localhost 30002 | grep -e pass
                </code>
            </pre>
            <p>
                I hope all of that makes sense to you at this point. We run the script, pipe it to the port we want and we use grep just to clean the output. I am using pass since I assume that the line we get with the password in it will contain the string "pass". If it doesn't I can just edit my grep or omit it. See you in the next level!
            </p>
        </div>

        <button class="accordion">Bandit 25</button>
        <div class="panel">
            <p>
                Here we get another sshkey to connect to bandit 26, however trying to log on to bandit 26 gets us kicked out. Lets see what we can do. We get some info from the bandit website. Firstly that it is not running a bash shell. 
                So lets see what is happening there.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat /etc/passwd | grep -e bandit26
                </code>
            </pre>
            <p>
                In this file we will be able to see information of all the users in plain text. We only care about <i>bandit26</i> so we <strong>grep</strong> for that.
            </p>
            <p>
                The output here will point us to: <i>/usr/bin/showtext</i>. Let's cat that to see what it is telling us.
            </p>
            <p>
                Ok, this is telling us that it is executes <i>more</i> on a text file and then closes out... so we need to force <i>mroe</i> into a command view. To do this make your terminal window as small as possible horizontally. Then we can <strong>ssh</strong>
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ssh bandit26@localhost -i bandit26.sshkey
                </code>
            </pre>
            <p>
                Now you will see a little % view in the bottom left. Make the screen a <i>little</i> bigger and press <strong>v</strong>. Now we are in a vim editor for bandit26! Weird right? But now we can do somethings on bandit26. We most importantly want a shell. We can tell vim to set a certain shell for us:
            </p>
            <pre class="codeBlocks">
                <code>
                    :set shell=/bin/bash
                </code>
            </pre>
            <p>
                So to get the colons press <strong>Esc</strong> then press the <strong>:</strong> and you will be able to start giving vim commands. We then tell vim to set the <strong>shell</strong> equal to a <strong>bash</strong> terminal. Press enter and that will change those settings.
            </p>
            <p>
                Then we just tell vim to execute a shell for us with:
            </p>
            <pre class="codeBlocks">
                <code>
                    :shell
                </code>
            </pre>
            <p>
                Bam! We are in bandit 26. We haven't gotten a password yet? Should we find one for bandit26? I mean you can go get it in  <i>/etc/bandit_pass/bandit26</i>, the issue is you will still need to do this exact same dance to get the shell for 26. I recommend staying in this shell and solving 26 - 27. It is SSSSOOOOOO easy compared to what we just did. See you there!
            </p>
        </div>
        
        <button class="accordion">Bandit 26</button>
        <div class="panel">
            <p>
                So... you decided to stay? Or... I knew you'd be back! Either or, welcome. This level is super easy. A quick <strong>ls</strong> will tell us there is an executable <i>bandit27-do</i>. Bet you can guess what this does.
            </p>
            <p>
                If not just run a <strong>./bandit27-do</strong>, it will tell you that it lets you run a command as another user, bandit27 in this case. Lets just use that to read the password file for bandit27.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ./bandit27-do cat /etc/bandit_pass/bandit27
                </code>
            </pre>
            <p>
                And we have the password! See you in bandit27!
            </p>
        </div>

        <button class="accordion">Bandit 27</button>
        <div class="panel">
            <p>
                Now we get to start using <i>git</i>. This is a version control software package that lets you keep track of changes made to you projects as they evolve as well as work on separate versions and then merge all the changes you like and reject the ones you don't. It really is a backbone of any kind of development. Learning how to use it in a basic way is very useful and there are many resources for this. So the next few challenges will all be using git and will teach some basic ideas of what to do and not to do for the security conscious. This one will teach you not to leave a password lying around. Let's get started.
            </p>
            <p>
                Once in the bandit 27 box we need to <i>clone</i> the repository they give us on the bandit website. <i>clone</i> is a git function that will copy an entire project for you in the directory that you are running the command in. We know that we can only create directories in the <i>/tmp</i> directory and then create our working directory.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ mkdir /tmp/wireGit

                    $ cd /tmp/wireGit
                </code>
            </pre>
            <p>
                In this directory we will then run the following command:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git clone ssh://bandit27-git@localhost/home/bandit27-git/repo
                </code>
            </pre>
            <p>
                This command instructs <strong>git</strong> to <strong>clone</strong> that exact repo. It will ask you to accept an ssh key, we covered this in bandit 0 so just say yes. You will then need to re-enter the password for bandit 27 and you will have the new <i>repo</i> dir.
            </p>
            <p>
                <strong>cd</strong> into the <i>repo</i>, run and <strong>ls</strong> and we will see a <i>README</i>, <strong>cat</strong> it and we have the password for bandit 28. Sweet and easy. Catch you in 28.
            </p>
        </div>

        <button class="accordion">Bandit 28</button>
        <div class="panel">
            <p>
                Another git one! Sweet, make another directory for your self in <strong>/tmp</strong> and clone down the repo linked on the website. Same recipe as the last bandit level
            </p>
            <p>
            Cool in the <i>repo</i> directory we see a <i>README.md</i>, <strong>cat</strong> that and..... oh... the password is a bunch of x? Uhm is this some kind of weird curve ball to teach us not to overthink? Trying it doesn't seem to work so I guess not. 
            </p>
            <p>
                Remember when I said <strong>git</strong> is a version control software? It keeps track of all the changes we make to files, well  because of this it keeps a log of previous versions of our files and the changes we made. If we run:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git log
                </code>
            </pre>
            <p>
                We will get a log of changes. And oh my... the latest one talks about an info leak. How can we see the changes made in that latest update? With this:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git log -p -1
                </code>
            </pre>
            <p>
                This will run the git log and tell it to generate the <strong>p</strong>atch. The -1 will limit it just to one output (the latest one). And there we have the password. Sweet see you in bandit 29!
            </p>
        </div>

        <button class="accordion">Bandit 29</button>
        <div class="panel">
            <p>
                Another git round. Same recipe as before. Make your dir in tmp and then clone the repo and let's get crackin'
            </p>
            <p>
                Cool, another read me. <strong>cat</strong> it and we see... <i>no passwords in production</i>. Mmm... well lets check our history like we did before. 
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git log -p
                </code>
            </pre>
            <p>
                Ok I see that the user name was changed.Does that mean that the user the password for bandit 30 could be the same as the password for bandit 29? Worth a look to see if it is a simple misconfiguration error. Fire up another terminal and try to log in with bandit 29's password on bandit 30. SPOILERS: It doesn't work. But it really is a quick thing to check and simple errors like this do happen. Not everything is an intensive technical issue. 
            </p>
            <p>
                Anyway that line: <i>no passwords in production</i>. Since git is a version control software we can use git to work on different things called <strong>branches</strong>. This is a clone of your code base that will allow you to make changes to your code or projects without affecting the main or production code. So that line makes me think maybe we have another branch? Let's run the next command and see what we get:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git branch -r
                </code>
            </pre>
            <p>
                That command will list all the branches we have for our current project. And nice, we see a few other branches. I'm gonna check the top one <i>dev</i>. How do we work in other branches? Same way you borrow a book from a library, you <strong>checkout</strong> the book!
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git checkout dev
                </code>
            </pre>
            <p>
                Now we are working in the dev branch. Neat! A simple <strong>ls</strong> will show us a new README.md. <strong>cat</strong> it and we have our next password. Awesome! See you in bandit 30.
            </p>
        </div>
        <button class="accordion">Bandit 30</button>
        <div class="panel">
            <p>
                Bandit 30.. Wow we have made it far... And it is another git bandit. Awesome! So same recipe. Make your directory to work in in <strong>/tmp</strong>, clone the repo and let's see what we have to work with.
            </p>
            <p>
                We have a <i>README.md</i> that just says it is an empty file... well that's great. Let's check the git history... Uhm no... nothing there this is the initial commit of the file. Maybe we have another branch again? No, that also does not appear to be it. Uhmm... if we run <strong>git log</strong> we get this weird string next to the word <i>commit</i>. Maybe they want us to think kinda laterally and we can try and use that as the password for 31? No that didn't work either. Uhm maybe they want us to run a base64 on this file and use that string? Also no. Man what gives, anything else on git we can check? Well there are these things called <strong>tags</strong>. 
            </p>
            <p>
                They are used to mark important points in a repository's history. They don't change and do not keep a history. Most people use them to mark release points (v1.0, v1.1.4 etc.). Maybe they hid something for us in a tag? To see them we use:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git tag
                </code>
            </pre>
            <p>
                Oh? We have one called secret. To read it we do this:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git show secret
                </code>
            </pre>
            <p>
                Nice, we got it! See you in bandit 31!
            </p>
            <i><sub>Side note, here I decided to write out some of the things I thought it could be or just decided to check. I want you to know that trying a lot of things that probably won't work will happen all the time. This is fine, completely fine, especially when you have as little info as they provide. I really hope you are still enjoying these so deep in!</sub></i>
        </div>

        <button class="accordion">Bandit 31</button>
        <div class="panel">
            <p>
                You guessed it. More git! <b>/tmp</b> directory and then then clone down the repo and lets get to work.
            </p>
            <p>
                Cool a read me that tells us we need to create and upload a specific file and what it contents should be. Pretty easy. To create the file with its contents we just:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ echo "May I come in?" > key.txt
                </code>
            </pre>
            <p>
                <strong>echo</strong> will just copy out a string. The <strong>&gt;</strong> just redirects the output to a new file. The <strong>key.txt</strong> is the file we redirect the output to and write it in the file.  
            </p>
            <p>
                Now we need to send this file to the git repo we cloned. To do this we first need to tell git what files we want to <strong>add</strong>
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git add key.txt
                </code>
            </pre>
            <p>
                Mmmm it tells us that the file is being excluded by .gitignore and we need to use the <strong>-f</strong> option to force it.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git add -f key.txt
                </code>
            </pre>
            <p>
                Now we need to make a <strong>commit</strong>. This is just a final seal on the package you want to add to the upstream git branch. We do this with:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git commit -m "add key.txt"
                </code>
            </pre>
            <p>
                The <strong>-m</strong> is specifies the message to add to the commit. git etiquette is do write all your messages in the present tense.  
            </p>
            <p>
                Now we just need to <strong>push</strong> the changes we want to make up to the main branch.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ git push
                </code>
            </pre>
            <p>
                Sweet! It rejects our commit, but we got the password! See you in bandit 32.
            </p>
        </div>

        <button class="accordion">Bandit 32</button>
        <div class="panel">
            <p>
                Bandit 32. This one is kinda quick and interesting. When we are logged in to a shell we are just told welcome to uppercase hell. So everything we enter as input gets converted to uppercase. That kind of sucks since none of these things are commands that the terminal can interpret.
            </p>
            <p>
                You may also wonder why the terminal icon is <strong>&gt;&gt;</strong>. This means that the bash command line is in interpret mode. No need to worry about this too much, all we care about is that we need to get out of it. And with bash we have an escape sequence that will let us do this: 
            </p>
            <pre class="codeBlocks">
                <code>
                    >> $0
                </code>
            </pre>
            <p>
                The above line just invokes a bash shell for us. Yay! we have our terminal back. If we type <strong>whoami</strong> we will be told we are bandit 33. We can get the password for bandit 33 in the /etc/ path. See you in bandit33!
            </p>
        </div>

        <button class="accordion">bandit 33</button>
        <div class="panel">
            <p>Welp.. there isn't much to do here since bandit 34 does not exist yet. So congratulations on completing bandit! Hope to see you in Leviathan if you have not already peeked there! Thanks for sticking around. </p>
        </div>
    </div>

    <button class="accordion">Leviathan  +</button>
    <div class="panel">
        <button class="accordion">Leviathan 0</button>
        <div class="panel">
            <p>
                Awesome, we made it to Leviathan on over the wire! Heck yeah. Or you decided to check this out somewhere in your bandit journey. That is cool too. How do we go about this one? Simple! To connect we:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ssh leviathan0@leviathan.labs.overthewire.org -p 2223
                </code> 
            </pre>
            <p>
                We covered this in Bandit0, but all we are saying here is we want to use <strong>ssh</strong> and we want to authenticate as user: <strong>leviathan0</strong> at the domain: <strong>leviathan.labs.overthewire.org</strong> to port <strong>-p 2223</strong>
            </p>
            <p>
                Nice! And we use the password <strong>leviathan0</strong> and we are golden! We get the same key prompt we did with bandit0, say yes again. We are in. Let's see what we have to work with:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ls -la
                </code> 
            </pre>
            <p>
                Ok we have a hidden folder called <i>.backup</i>
            </p>
            <p>
                <strong>cd</strong> into it and we can see what it has with another <strong>ls</strong>. An .html file,  nice. We can <strong>cat</strong> it to see what it says:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat bookmarks.html
                </code> 
            </pre>
            <p>
                Wow that is a lot. I'd rather not read all of that. So... I wanna see if maybe they mention anything about leviathan in that document, since that is the system we are working with. I can use <strong>grep</strong> for that:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat bookmarks.html | grep -e leviathan
                </code>
            </pre>
            <p>
                All of that should make sense to you at this point. <strong>cat</strong> reads the file <i>bookmarks.html</i> and pipe redirects that output to <strong>grep</strong>. <strong>grep -e leviathan</strong> says we want to use the program <strong>grep</strong>, <strong>-e</strong> says what follows is the expression we want to match and <i>leviathan</i> is the string.
            </p>
            <p>
                Now we have much less output. If we read that string we will see it tells us the password for <i>leviathan1</i>. Grab it and I will see you there.
            </p>
        </div>

        <button class="accordion">Leviathan 1</button>
        <div class="panel">
            <p>
                Now that we are in Leviathan 1, if we run <strong>ls</strong> we will see a file called <em>check.</em> Running this file we will see that it asks us for a password. Uhm... not sure on where we are supposed to get that form.. 
            </p>
            <p>
                We get this cool tool called <strong>ltrace</strong> though, this is a debugger and what it basically does is intercept all the commands and system calls that a program uses while it is executing until it is done.If we run <strong>ltrace</strong> we can thus see what this program is doing.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ltrace ./check
                </code>
            </pre>
            <p>
                Press enter again a few times and we will get to the <strong>exited</strong> which tells us the program stopped. Now we get to see some interesting things. Most importantly: <strong>getchar</strong> is what the system uses to get input from us. <strong>strcmp</strong> is a string compare that will compare out input to some other value. In this case "<strong>sex</strong>", and then lastly we have the <strong>puts</strong> that will just print out a message to us. 
            </p>
            <p>
                Anyway, so we know what password the program wants based on the strcmp. We can then execute <strong>./check</strong>, give it the password of "sex" and we will get a new prompt. Running <strong>whoami</strong> will tell us we are leviathan2. You can then grab the password for leviathan2 by running:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat /etc/leviathan_pass/leviathan2
                </code>
            </pre>
            <p>
                See you in the next level!
            </p>
        </div>

        <button class="accordion">Leviathan 2</button>
        <div class="panel">
            <p>
                This is a pretty fun one. When we ls we get a binary <em>printfile</em> if we run it we will see that it let's us print files with different privileges. running it, it just tells us to give it a file name. So lets give it something to read and run ltrace on it to see what is happening:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ltrace ./printfile /etc/passwd
                </code>
            </pre>
            <p>
                So here we are running <strong>ltrace</strong> on the <strong>./printfile /etc/passwd</strong> since this is a file we can read. We will see that basically all this is doing is running <strong>cat</strong> on the file name we give it. <em>But</em>.. this lets us do something really interesting. We can do a command injection.  
            </p>
            <p>
                What we are going to do here is create a file to read and then end the name in <strong>;bash</strong>. Well why? First remember how cat works. <strong>cat</strong> takes a file name and will print out the files contents. Magic right? Remember what happens if we say "<strong>cat this file</strong>"? Yep, cat wants to read two files. One called <em>this</em> and one called <em>file</em>. Ok, we are getting somewhere. Next thing to know is that the <strong>;</strong> means <em>end this statement/command</em>.  
            </p>
            <p>
                If we look at the code for the <strong>snprintf</strong> in the ltrace we will see that it is telling us it will grab the file name we give it and append it to the cat command it is programmed to run. Why does this matter? Well since it is taking the string and not keeping the file name in quotes (or escaping some functions that could be invoked) we can inject commands into this program by adding <strong>;</strong> in a file name. 
            </p>
            <p>
                So now let's make a tmp folder for us to work in. 
            </p>
            <pre class="codeBlocks">
                <code>
                    $ mkdir /tmp/wireInject
                </code>
            </pre>
            <p>
                Now we make a file that will be used to inject our command:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ touch "test;bash"
                </code>
            </pre>
            <p>
                Here your file name needs to be in quotes. If it is not you will just make a file called test and then execute the command <em>bash</em>, since the <strong>;</strong> denotes end of line and run the next command. And now we can run our attack:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ~/./printfile test\;bash
                </code>
            </pre>
            <p>
                So some new things here. Since we are in a different folder and want to run a command that is in our home folder we need to specify that path. <strong>~</strong> is the symbol for home. The next <strong>/</strong> puts us in that directory and the <strong>./printfile</strong> we know will execute the command. Then we have the name of the file we want to give to printfile. No, the <strong>\</strong> is not wrong there and you should not include it in your file name when making the file, that is just how the input to the <em>printfile</em> program wants it. Run this and you will get an error. That is fine, but if you look at your prompt you will now see that you are leviathan3.
            </p>
            <p>
                So what happened? Basically what we eluded to at the start. We exploited how the binary interprets the file name we give it. After we created the file <em>test;bash</em> and fed it to the program, the program read it as:
                <ul> 
                    <li>
                        <em>first I should <strong>cat</strong> the file <strong>test</strong> then there is the <strong>;</strong> which means this command is done.</em>
                    </li> 
                    <li>
                        At this point we are still running commands as leviathan 3 as this is what this binary lets us do. (it does however check user ids, which is why you can't use it to just read the password file for leviathan 3).
                    </li> 
                    <li>
                        Then the program interprets the command after the <strong>;</strong> which is a simple <strong>bash</strong>, this will invoke a bash for leviathan 3 and we can now get the password for leviathan 3 in the <strong>/etc/leviathan_pass/leviathan3</strong>.
                    </li>
                </ul>
            </p>
            <p>
                Sweet that was a bit, but so cool and I hope you learned a lot. Or at least an idea of how whacky some things can get, but still fun and interesting. Also why you should understand how certain programs interpret input. As command and code injections will be your bread and butter. See you in the next level! 
            </p>
        </div>

        <button class="accordion">Leviathan 3</button>
        <div class="panel">
            <p>
                Well, this one is gonna be pretty easy. It just really builds on the last few levels. We have a binary called <em>level3</em>. If we run it we get a prompt for a password. Just type anything in there and we get an error. Guess it is ltrace time?
            </p>
            <pre class="codeBlocks">
                <code>
                    __libc_start_main(0x8048618, 1, 0xffffd784, 0x80486d0 <unfinished ...>
                        strcmp("h0no33", "kakaka")                       = -1
                        printf("Enter the password> ")                   = 20
                        fgets(Enter the password> tests
                        "tets\n", 256, 0xf7fc55a0)                 = 0xffffd590
                        strcmp("tets\n", "snlprintf\n")                  = 1
                        puts("bzzzzzzzzap. WRONG"bzzzzzzzzap. WRONG
                        )                       = 19
                        +++ exited (status 0) +++
                        
                </code>
            </pre>
            <p>
                <ul>
                    <li>
                        Mmm... ok, so it starts with a <em>strcmp</em> that is comparing two strings that won't match? Not really sure why that is there or what it is doing.
                    </li>
                    <li> 
                        Then we have our <em>printf</em> that prints the output of "enter the password" to the screen.
                    </li> 
                    <li>
                        The <em>fgets</em> is what will take our input and give it back to the program to compare later.
                    </li> 
                    <li>
                        Then we get the <em>strcmp</em> that is comparing our input to the input we really want. <strong>snlprintf</strong>. And there is our password.
                    </li>
                </ul>
            </p>
            <p>
                Now if we run the program again and we give it the password <strong>snlprintf</strong> we will get a new shell. Running a <strong>whoami</strong> will tell us we are leviathan4. Now we can just go read the password file in: <em>/etc/leviathan_pass/leviathan4</em> and I will see you in the next level!
            </p>
        </div>

        <button class="accordion">Leviathan 4</button>
        <div class="panel">
            <p>
                This one is pretty basic. After you are in the box and run and <strong>ls -la</strong> you will see a hidden folder named <em>.trash</em>. <strong>cd</strong> into it and you will see there is a <strong>bin</strong>. Run it and it will... Just print out a bunch of binary? Any tools to reverse it? There are quite a few ways to approach getting this back into a string, but I just recommend using the cyber chef website, it allows you to convert from almost any type of input to almost any type of out put.  
            </p>
            <p>
                Copy and paste it into the website with input being binary and output being ASCII and you are good to go. 
            </p>
            <p>
                Looking into ways to do this in the terminal only there are many ways to skin this cat. The quickest one is perl one liner we can use in the command line. So you would want this:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ echo 01010100 01101001 01110100 01101000 00110100 01100011 01101111 01101011 01100101 01101001 00001010 | perl -lape '$_=pack"(B8)*",@F'
                </code>
            </pre>
            <p>
                I am no expert on perl and I found this solution online. That is fine for you to do. This is just if you want a command line way. There is just too much to learn and know to expect yourself to master everything. In looking for ways to solve this I saw a lot of different approaches. Bash scripts, c programs, you can even do this by hand if you wanted. But honestly, use cyber chef. It will save you hours. If you want to write these scripts and programs as a challenge to yourself, great! But don't overwhelm yourself. See you in the next level!
            </p>
        </div>

        <button class="accordion">Leviathan 5</button>
        <div class="panel">
            <p>
                Ok this one is kinda weird. Running an ls -la we will see we have a bim <em>leviathan5</em>. If we run it, it tells us the file <em>/tmp/file/log</em> does not exist. Ok... let's run <strong>ltrace</strong> to see what is happening.
            </p>
            <p>
                Ok... so it wants to use <strong>fopen</strong> to read a file. Mmmm... Back to that <strong>ls -la</strong>. We can see that <em>leviathan5</em> is owned by leviathan 6. So... maybe we can try and link the password file for leviathan 6 to the file.log and then read the password that way?
            </p>
            <pre class="codeBlocks">
                <code>
                    $ ln -s /etc/leviathan_pass/leviathan6 /tmp/file.log
                </code>
            </pre>
            <p>
                <ul>
                    <li>
                        <strong>ln</strong> says we want to create a link
                    </li>
                    <li>
                        <strong>-s</strong> says that we want a symbolic link, basically the same thing as a Windows shortcut. They point to a file. If you edit the link file, the original file will be edited as well, but if you delete this linked file the original file remains.
                    </li>
                    <li>
                        Then we have the file we want to link, the source file
                    </li>
                    <li>
                        Lastly we have the file we want to link to. The file should not be made before hand. The ln command will make this for us. 
                    </li>
                </ul>
            </p>
            <p>
                Sweet, now that all of that has been done we can execute the binary and get the password. Nice! See you in the next level!
            </p>
        </div>

        <button class="accordion">Leviathan 6</button>
        <div class="panel">
            <p>
                With this one we have done a similar box in bandit. When we log in to the box we see a bin <em>leviathan6</em>. Run it and it says we use it by running the binary with a 4 digit pin. Well, we do not know this pin and I don't think it is retrievable. Brute force time!
            </p>
            <p>
                If you remember how to do this from our bandit box. First we make out working directory in <em>tmp</em> and then <strong>cd</strong> to it:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ mkdir /tmp/wireBrute && cd /tmp/wireBrute
                </code>
            </pre>
            <p>
                The only potentially new thing there is the <strong>&&</strong> this is a logical and operator. What this means is, if the command on the left succeeded, execute the command on the right. So you should now also be in the directory you made. 
            </p>
            <p>
                Now for the brute force script. As stated we already did something similar in a previous bandit box, so you should definitely be able to do this. But here is the code if you need a quick review.    
            </p>
            <pre class="codeBlocks">
                <code>
                    #!/bin/bash

                    for number in {0000..9999}
                    do 
                    <span style="visibility: hidden;">aa</span> ~/./leviathan6 $number
                    done
                </code>
            </pre>
            <p>
                Sweet. Just quickly.
                <ul>
                    <li>
                        <strong>#!/bin/bash</strong> tells the system what shell to interpret the script with
                    </li>
                    <li>
                        <strong>for number in {0000..9999}</strong> sets up the variable number and the range for it to run through
                    </li>
                    <li>
                        <strong>do</strong> starts the loop
                    </li>
                    <li>
                        <strong>~/./leviathan6 $number</strong> is the command we want to execute
                    </li>
                    <li>
                        <strong>done</strong> ends the loop
                    </li>
                </ul>
            </p>
            <p>
                Give this command a while to run and you will end with a <strong>$</strong>. Type who am I and you will see we are <em>leviathan7</em>. Get the password for levithan7 in <em>/etc/levithan_pass</em> and I will see you in the last level!
            </p>
        </div>
        

        <button class="accordion">Leviathan 7</button>
        <div class="panel">
            <p>
                Well... there isn't a challenge here, just the congratulations file. Give it a read. Be proud of what you did and I will see you in <strong>KRYPTON!</strong> Thanks for sticking around!
            </p>
        </div>
    </div>

    <button class="accordion">Krypton +</button>
    <div class="panel">

        <button class="accordion">Krypton 0</button>
        <div class="panel">
            <p>
                Welcome to Krypton. We have been on this journey for a while and we will be here a little longer. So let's get going!
            </p>
            <p>
                Interestingly enough, we solve Krypton 0 on our local machine. The give us an encoded string and tell us it is <em>base64</em> encoded. So to do it and get the password for Krypton 1 all we have to do is:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ echo "S1JZUFRPTklTR1JFQVQ=" |  base64 -d
                </code>
            </pre>
            <p>
                All we are doing here is repeating the string, piping it to the base64 command and using the -d flag to decode it. 
            </p>
            <p>
                Use that password and I will see you in Krypton1!
            </p>
        </div>

        <button class="accordion">Krypton 1</button>
        <div class="panel">
            <p>
                So here the password is kept in a file called <em>Krypton 2</em>, it is a simple rotations cypher (also known as a Caesar cipher). What this means is that each letter in the alphabet move a certain number of letters to the right or left. So a rotation 1 cipher would mean: a = b. b = c ... z = a. You may have thought of something similar when you were a child and sending notes around class.
            </p>
            <p>
                Next we have a somewhat confusing statement: "When using alpha characters for cipher text it is normal to group the letters into 5 letter clusters, regardless of word boundaries." All this is saying is that usually you group letters in groups of 5, regardless of how long the word is. This isn't done here, so the number of letters is a clue to the length of the actual word. 
            </p>
            <p>
                Now that we are logged in to Krypton1 we need to see this encrypted string. Running an <strong>ls</strong> however doesn't show us this file. So let's find it on the system:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ find / -name krypton2 2>/dev/null
                </code>
            </pre>
            <p>
                I hope that still makes sense to you after bandit, but here we are just saying <strong>find</strong> form <strong>root</strong> every thing with the <strong>name krypton2</strong> and then <strong>redirect all errors to /dev/null</strong>.
            </p>
            <p>
                We get <em>/krypton/krypton1/krypton2</em> so then we <strong>cd</strong> to <em>/krypton/krypton1</em> and we can read this cipher and we end up with this: <strong>YRIRY GJB CNFFJBEQ EBGGRA</strong>. Uhm.... well if we look up rotation cipher we can gather that the most common cipher is a rot13... we can try that one first? On rot13.com we can enter the string and we will get the password for level 2. Sweet. 
                
            <p>
                 If that is a little disappointing. I am no expert in cryptography and more often than not going after the common ways of attacking the ciphers is the best approach. Spending time trying to crack the cipher is fun.. but will take a lot of your time when they have already been broken by people who are geniuses at this stuff.
            </p>
            <p> 
                But the easiest way too attack a cipher like this one where word boundaries are not a problem. Is to look at the number of letters in the encrypted word. Find a list of all words of similar length and write up the cipher and crack by hand.
             </p>
            <p>
                For example YRIRY is a five letter word. Where the first and fith letter are the same and the second and forth letters are the same and the third letter is unique. I do not have a list. But I am pretty sure there are not too many words like that in the english language (126 5 letter palindromes according to lotsofwords.com).
            </p>
            <p>
                Then we also have context clues. We have a rough idea of the word we will be looking for. <em>Level</em> makes sense. Looking at the list on lotsofwords.com something like <em>anona</em> won't really make sense in the context of this cipher and the answer we expect to get. Level, civic and radar could all be viable? So at that point you just need to map the letters and you can try and decrypt the string.   
            </p>
            <p>
                Ok, I know I went on for a bit there, but please remember, unless you really want to get deep in to the mathematical field of cryptography. When you run into encrypted ctfs, more often than not you will attack it with common ciphers and tools. Yes this does feel a bit like throwing darts in a dark room, but it works. See you in the next level!
            </p>
            <p>
                Side note: If you want a command line way of doing this. In one of the bandits we cover how to solve a rotation 13 cipher with the <strong>tr</strong> command.
            </p>
        </div>

        <button class="accordion">Krypton 2</button>
        <div class="panel">
            <p>
                Another encryption one, no surprise there. I think Krypton is only encryption related wargames. Here we will get a binary <em>encrypt</em> that will encrypt any file we give it. We do not know what kind of cipher it is using however. 
            </p>
            <p>
                We also have a <em>Krypton3</em> file that is the password to the next level. This file was encrypted with the same <em>encrypt</em> binary. So all we have to do is run the binary on a file we created and we can figure out how the cipher works. Not to hard. So first let's make a temporary working directory:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ mkdir /tmp/wireKrypt2 && cd /tmp/wireKrypt2
                </code>
            </pre>
            <p>
                That will just create the dir and then we <strong>cd</strong> to it. Next we will create a text file that will contain the alphabet so that we can see how the cipher works.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ echo "ABCDEFGHIJKLMNOPQRSTUVWXYZ" > alpha
                </code>
            </pre>
            <p>
                Now that it exists let's also link the keyfile that we want to use.
            </p>
            <pre class="codeBlocks">
                <code>
                   $ ln -s /krypton/krypton2/keyfile.dat
                </code>
            </pre>
            <p>
                And lastly we will just change permissions here so that we can run everything.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ chmod 777 .
                </code>
            </pre>
            <p>
                Awesome, awesome. All this setup done. All we did again in sumarry is:
                <ul>
                    <li>
                        Create a temporary directory to work in
                    </li>
                    <li>
                        Create a know file that we can use to encrypt with our cipher so that we can figure out how it works. We chose the alphabet as this will give us a firect one to on mapping of the cipher.
                    </li>
                    <li>
                        Link the keyfile for the cipher to our working directory.
                    </li>
                    <li>
                        Give ourselves blanket permissoins over everything in our tempotaty directory.
                    </li>
                </ul>
            </p>
            <p>
                Now all that is left to do is execute the binary on this file and see what we end up with.
            </p>
            <pre class="codeBlocks">
                <code>
                    $ /krypton/krypton2/encrypt ./alpha
                </code>
            </pre>
            <p>
                Nice, then out the other end we get a file: <em>ciphertext</em> and from that we can see the shift the cipher takes. 
            </p>
            <p>
                Now the last step to decode would be to run our <em>krypton3</em>  file through a <strong>tr</strong> that represents this cipher:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat /krypton/krypton2/krypton3 | tr [M-ZA-L] [A-Z]
                </code>
            </pre>
            <p>
                Nice, we got our password. A quick recap of what the above is saying. We read the password file with <strong>cat</strong> and pipe it to our <tr>command</tr>. The first alphabet we use is the already encrypted one (since we want to decrypt).
            </p> 
            <p>
                <em>A little side not here: if you get these shifted you will always go from (n)-ZA-(n-1). You will always need to end in a <strong>z</strong> en then start from an <strong>a</strong> to the letter just before the letter the cipher starts with.</em>
            </p>
            <p> 
                Then the alphabet we want to decrypt to (in this case our normal A-Z alphabet)
            </p>
            <p>
                Cool, see you in Krypton3!
            </p>
        </div>
    </div>



    
    <script src="script.js"></script> 
</body>
</html>