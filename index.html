<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wire Runner</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1>Welcome to Wire Runner!</h1>
 
        <img src="wirerunner.gif"  id="wireRunner" height="150px"/> 

    <p style="text-align: center;">
        Here you will find your guide to and explanation of Over The Wire challenges. All commands are run from the Linux bash terminal.
    </p>

    <button class="accordion">Bandit  +</button>
    <div class="panel">
        <button class="accordion">Bandit  0</button>
        <div class="panel">

            <p>
                For level 0 of over the wire we will just need to login The details are given for us. The little dollar sign is a terminal character that means the command is being run as the user you are logged in as. Login using the following:
            </p>

            <pre id="codeBlocks">
                <code>
                $ ssh bandit0@bandit.labs.overthewire.org -p 2220 
                </code> 
            </pre>
            
            <p>
                What does all the above letter soup mean you wonder? Let's break it down!
            </p>

            <p>
                First with <b>ssh</b> we tell the computer. "Hey, you have this thing called <b>S</b>ecure <b>SH</b>ell. I want to use that command."
                <br/><br/>
                Then we say where we want to ssh to. You will see the next part kinda looks like an email? It can be interpreted in the same way. The first part before the @ is the user we want to be. In this case bandit0. After the @ is the domain we want to be at. In this case: bandit.labs.overthewire.org. Neat! <br/><br/>
                Lastly we have this weird <b>-p</b> thing... what's that about? Long story short this specifies the network port you want to connect to. Web servers use ports to keep their services and communication streams separate.
             </p>
            <p>
                If you have never logged in to over the wire you will be prompted to accept a Key. Huh? What? Keys? <br/><br/>
                Basically what is happening here is. When you encrypt something you and the person you are talking to need to agree on how things will be encrypted. This key is part of the cipher you will need to encrypt things to securely talk to the server you are connecting to. <br/><br/>
                What does all this "The authenticity of host '[bandit.labs.overthewire.org]:2221 ([176.9.9.172]:2220)' can't be established." Mean? Well in the scary world of the internet we have some authorities that can validate that someone is who they say they are. This is just saying these authorities don't have a record for this key or who it belongs to. Rest assured though. You can accept this key. So just say yes.
            </p>
            <p>
                Next we will be prompted for the password to login with. Luckily they give this to you!
            </p>
            <pre id="codeBlocks">
                <code>
                bandit0  
                </code> 
            </pre>
            <p>
                Enter this password and you are now logged in as another user, on another computer, somewhere else completely on the earth. That's insane!
            </p>
            <p>
                The next instructions are also given to you this early in the game. The next password is in a file called <b>readme</b> and we use that password to login to the next level. To read it use the <b>cat</b> command.
            </p>
            <pre id="codeBlocks">
                <code>
                $ cat readme 
                </code> 
            </pre>

            <p>
                The <b>cat</b> command just reads some text and prints it out to the terminal for you to read. I still personally like to imagine that the floating cat head from Alice in wonderland is reading it to me.
            </p>
            <p>
                Copy this weird long looking password. Exit your connection session by typing:
            </p>
            <pre id="codeBlocks">
                <code>
                $ exit 
                </code> 
            </pre>
            <p>...into your terminal. And you should be back to your home terminal.</p>
            <p>Sweet! We did it. Now we can go on to the next level. Ready?</p>
        </div>

    
        <button class="accordion">Bandit  1</button>
        <div class="panel">
            <p>
                Now we are at our first challenge. here the password is stored in a file called: <b>-</b>
            </p>
            <p>
                Cool, we read a file last time... just use <cat>cat</cat>? Ah... doesn't work.. what gives?
            </p>
            <p>
                When cat sees the "-" it does not interpret this as a file name, it interprets it as another way to represent stdin (standard input, basically where your computer receives input from, no need to worry about this to much at the moment).
            </p>
            <p>
                Well how do we get around this? We would need to tell cat to interpret this as a file name. To do this we need to use a special character combination in linux:
            </p>
            <pre id="codeBlocks">
                <code>
                $ ./ 
                </code> 
            </pre>
            <p>
                Well that looks really weird... what does it do? In linux this is a way to tell a command, or anything almost that "Hey, I want to to look for or do this thing in the directory that we currently are." Directories are the same thing as folders on Windows.
            </p>

            <p>
                So to read the password file we would need to:
                <pre id="codeBlocks">
                    <code>
                    $ cat ./- 
                    </code> 
                </pre>
            </p>

            <p>
                Great! That was weird but not too hard. Ready for the next level? Let's go!
            </p>
        </div>


        <button class="accordion">Bandit 2</button>
        <div class="panel">
            <p>
                So our next machine needs us to open a file with spaces in it. Luckily this is super easy. 
            </p>
            <p>
                What makes opening a file with spaces different is that the terminal does not interpret the space as space character. It thinks you want to open another file. So:
            </p>
            <pre id="codeBlocks">
                <code>
                $ cat this file
                </code> 
            </pre>
            <p>
                Would be asking the computer to:<br>
                -cat the file: this<br>
                -cat the file: file<br>
                So the error we will get with this is telling us that the file name we put in to cat does not exist. As all of these treated as separate file names and are thus not valid names of things that we can cat.
            </p>
            <p>
                How do we get around this? There are two ways we can go about this
            </p>
            <p>
                Well we need to tell the terminal that the string of text we put in is the exact wording. And just as with english. We use quotes! So we need:
            </p>
            <pre id="codeBlocks">
                <code>
                $ cat "spaces in this filename"
                </code> 
            </pre>
            <p>
                Basically what this is saying is. Everything in the quotes is the exact words and formatting(spaces included) that I want.
            </p>
            <p>
                Another way we can do this is with back slashes. What these do is they escape the function of the character being fed to the terminal. So by default it would mean "Hey here is a space, so things after this character is considered a new file.". By escaping this meaning we can have the space be what we are use to it being in text files. So it would look like:
            </p>

            <pre id="codeBlocks">
                <code>
                $ cat spaces\ in\ this\ filename
                </code> 
            </pre>
            <p>
                Woah! That looks kinda funky! Do I need to remember how to format this? Luckily not! Linux has this super cool feature called tab complete.
            </p>
            <p>
                What tab complete does is search for files or folders in the directory that you are currently in and try and match the name as best as possible. So try typing:
            </p>
            <pre id="codeBlocks">
                <code>
                $ cat sp
                </code> 
            </pre>
            <p> 
                And now press tab. It will complete it all for you! Sweet! 
            </p>
            <p>
                Submitting the command one of these two ways will get you the next password and we are on our way to level 3!
            </p>
        </div>


        <button class="accordion">Bandit  3</button>
        <div class="panel">
            <p>
                Cool. Now we are in level 3. In this level our password is in a hidden file in a folder.
            </p>
            <p>
                First, let's find our folder. How do we do this in the text based terminal Matrix? We use the command: 
            </p>
            <pre id="codeBlocks">
                <code>
                $ ls
                </code> 
            </pre>
            <p>
                Well... what does this do? Simple, it just <b>L</b>i<b>S</b>ts everything in the directory that you are currently in. We will then see a directory named: <i>inhere</i>
            </p>
            <p>
                Well how do we get into "inhere" We use this command:
            </p>
            <pre id="codeBlocks">
                <code>
                $ cd inhere
                </code> 
            </pre>
            <p>
                This means <b>C</b>hange <b>D</b>irectory and is a command you will use so much that you will feel like a CD with only one song on it.
            </p>
            <p>
                New directory, new files and directories to find. <b>ls</b> time! What? Huh? ls didn't work? Or the directory is empty? Did I and over the wire just lie to you?
            </p>
            <p>
                Now we get to hidden files and folders. How do we see those? We use the command:
            </p>
            <pre id="codeBlocks">
                <code>
                $ ls -la
                </code> 
            </pre>
            <p>
                This will list everything in a <b>l</b>ong format (gets you extra juicy details) and will list <b>a</b>ll of the files and directories. These can be spotted with the "." (dot) that the file or directory name starts with. In this case the file with the name "<i>.hidden</i>" .
            </p>
            <p>
                Why the naming convention? Not sure really. Someone just decided that's the way (ah-ha ah-ha) they like it.
            </p>
            <p>
                Anyway you can now just cat the hidden file (be sure to include the period in the name) and you can read the password for the next level.
            </p> 
            <pre id="codeBlocks">
                <code>
                $ cat .hidden
                </code> 
            </pre>

            <p>
                See you in the 4th dimension!
            </p>
        </div>


        <button class="accordion">Bandit  4</button>
        <div class="panel">
            <p>
                The next password is in the only human readable file in the "<i>inhere</i>" directory. What does that mean?
            </p>
            <p>
                Well anything that isn't really data files. That definition should be good enough for now.
                But to see what one looks like, after you <b>cd</b> into the inhere directory. Run an <b>ls</b> so that we can see all the files. let's open the first file. They are all dashed file names. Luckily we have also touched on these before. So run the command: 
            </p>
            <pre id="codeBlocks">
                <code>
                $ cat ./-file00
                </code> 
            </pre>
            <p>
                What just happened to the terminal? That is a mess! Luckily to clear up this mess all we have to do is well.. clear it. Run this command:
            </p>
            <pre id="codeBlocks">
                <code>
                $ clear
                </code> 
            </pre>
            <p>
                That looks better. Well how do we find the file we want?
            </p>
            <p>
                Linux has this cool command called <b>file</b> we give it the name of a file we want to know the type of and it will tell us what the data in the file tells the program it is. (So if you make a text file, but change the extension to be .png, you won't be fooling file)
            </p>
            
            <p>
                So we gotta run file on all of these until we get the right one? I mean... you can, I won't stop you. Or... we can do this:
            </p>
            
            <pre id="codeBlocks">
                <code>
                $ file ./*
                </code> 
            </pre>
            
            <p>
                So we know what <b>file</b> does... and we know what <b>./</b> means.... what is the asterisk (<b>*</b>) doing? It is a wild card symbol. It is a way to tell the terminal match anything. I don't care what it is or what it is called, it is a match. So *.txt would mean all text files. *.mp3 would be all mp3s.  
            </p>
            <p>
                The above command is just saying use file on all things in this directory. You will see one of the files has a different file type. You can <b>cat</b> this file (remember how to cat things starting with a "-"? If not just scroll up to bandit 1). And we have the password for level 5. See you there!
            </p>
        </div>


        <button class="accordion">Bandit  5</button>
        <div class="panel">
            <p>
                So, we have made it to level 5 and now we get to start putting a lot of things together. In this challenge our file is one of many files in one of many folders, and has quite a few properties.
            </p>
            <p>
                It is human-readable, 1033 bytes in size and not executable. The only one we really care about is the file size. How are we going to find this file without going through each file and directory?
            </p>
            <p>
                Easy, Linux has a <b>find</b> command. Find works by default by starting from the directory you run it in and going down the directory tree. We can learn more about the command and its arguments by using the <b>man</b> command
                <pre id="codeBlocks">
                    <code>
                    $ man find
                    </code> 
                </pre>
                This will open a document that will explain the command and many of its potential uses and options to you. Enough about this though, let's get to finding that file!
            </p>
            <p>
                So we know we can use the <b>find</b> command and we have some details about the properties of the file we want to find, most notably its size. We can use this to narrow down the amount of files it could be. So let's run this from the home directory (not in any subdirectories such as any of the <i>maybehere</i> directories.
            </p>
            <pre id="codeBlocks">
                <code>
                $ find -size 1033c
                </code> 
            </pre>
            <p>
                So the above command says we want to use find from where we are running the command in the directory tree and down, and we are looking for a file with the <b>size</b> of <b>1033c</b> The <b>c</b> is to denote bytes.
            </p>
            <p>
                We will get one matching file. Now you can either <b>cd</b> to the directory the file is in, or copy the whole output of find and paste it after cat. So it will look like:
            </p>
            <pre id="codeBlocks">
                <code>
                $ cat ./inhere/maybehereXX/XXXX
                </code> 
            </pre>
            <p>
                I am omitting the correct path as not to spoil it.
            </p>
            <p>
                Grab that password and we are on to level 6!
            </p>
        </div>


        <button class="accordion">Bandit  6</button>
        <div class="panel">
            <p>
                This level is pretty much the same thing as the last one. We will use <b>find</b> again. With a few more parameters. Our file has a few properties again. It is <i>somewhere</i> on the server, meaning we would need to search the whole directory tree. It is owned by group 6 (We won't really be using this info). It has a size of 33 bytes.
            </p>
            <p>
                Sweet so from all that info we can do this:
            </p>
            <pre id="codeBlocks">
                <code>
                $ find / -size 33c -user bandit7 2>/dev/null
                </code> 
            </pre>
            <p>
                Looks kinda familiar... right? Let's look at what every part of that... incantation means. We have used <b>find</b> so we know what that does. What's the  <b>/</b> doing? Well remember when I said that find works by search from where you are and down the directory tree? Here we are telling find where to start from. The / is a way of declaring the root of the directory tree, so it will search through <i>everything</i>... the whole system. At least everything your user has permission to access. More on that in a bit.
            </p>
            <p>
                <b>size</b> we touched on, this just lets us specify how big the thing we want to find is.
            </p>
            <p>
                <b>user</b> is a new one. Not too hard to guess what it means though. It is just the name of the user that owns the file or directory.
            </p>
            <p>
                Now the weird one. What is this <b>2>/dev/null</b> thing? This is not a part of find. This lets us manipulate the output we will get from find. So remember when I said <i>"At least everything your user has permission to access."</i> When we use find it will tell us when it cannot access a certain directory because it does not have permission, it does this mainly to inform you that, "Hey, I couldn't look through this thing further, I'm just letting you know so that you can decide on what to do about that. Do you wanna give me permission? 'Cause your file might exist there.". This is where we get to the <b>2</b> this is a way to specify stderr (standard error). All outputs that are errors use this instead of stdout (standard out). No need to worry about what these are now. Basically the system just handles how it presents standard output and error output a little different, and we currently care about the errors to clean up our output. So 2 means error output. 
            </p>
            <p>
                Now we have the <b>></b>. This is a redirect. It is what we use to tell output from things where to go if we do not want to use the defaults.
            </p>
            <p>
                Then we have /dev/null . This is a directory path, no? Yes! Exactly we are redirecting it to what is essentially a black hole in Linux. Anything you send here will just vanish into the void.
            </p>
            <p>
                You can run the command without the <b>2>/dev/null</b> and see what it did.
            </p>
            <pre id="codeBlocks">
                <code>
                $ find / -size 33c -user bandit7
                </code> 
            </pre>
            <p>
                Looks kinda messy huh? Now you get all those errors cluttering up your screen. Let's run the one that does redirect again to get our less cluttered output.
            </p>
            <p>
                You should now see two results. We could use the <b>-group bandit6</b> flag here as well, but I think this level of "perfect" command is not needed, and we will touch on this more in level 7 and beyond.  You can either cat both or just the one, should be pretty clear by the file name which one it would be. Again you can either <b>cd</b> all the way to the directory that the file is in and <b>cat</b> it there or you can just <b>cat</b> it from where you are specifying the file path like this:
            </p>
            <pre id="codeBlocks">
                <code>
                $ /XXX/XXX/XXX/XXX/xxx.obviousFileName
                </code> 
            </pre>
            <p>
                Again I left out the file path and name so that I don't make it too easy for you. Grab that password and we are on our way to lucky number 7.
            </p>
        </div>


        <button class="accordion">Bandit  7</button>
        <div class="panel">
            <p>
                Lucky number 7. Here we get into the minefield known as <b>grep</b>. Before we continue with that. This is where things  will start getting really weird and there will start to be multiple ways to do things and finding the answer, this will just be what I did that was good enough. So now I want to stress the importance of not looking for a "perfect" answer. Grep and Regex have books written about them, and every language has it's own regex (regular expression) quirks. So again, do not worry about how to get a 100% correct answer that will only get you the password as output. Get something that is close enough, get the password and move on. Serious bit aside. Let's get started. Luckily the grep in this level is still pretty easy.
            </p>
            <p>
                So what is grep and why is it so terrifying? GREP stands for Global Regular Expression Printer. What does this mean? What is a Regular Expression? A regular expression is a string of letters and symbols we can define so that we can match words in a text file. So I can use GREP to find the string of letters "cat" in a file of my choice, and every time I talk about cats (which is a lot), grep will return that instance of the word. Doesn't sound too hard, and that concept isn't. Where grep gets wild is we can use it to search for things that aren't explicit words. I can tell grep something like: 
            </p>
            <pre id="codeBlocks">
                <code>
                $ grep -e [0-9][a-z][dD]f myfile.txt
                </code> 
            </pre>
            <p>
                Yeah.... what? How is that even a thing? What does that even mean? Let's take it piece by piece.
            </p>
            <p>
                First we just have the command <b>grep</b>, which is just asking the terminal to use the command grep in all of its goodness.
            </p>
            <p>
                Next we have <b>-e</b>. This lets grep know that whatever is following is the expression we want to use. The expression can also be put in single or double quotes. so: "expression" or 'expression', but I have seen instances where how different terminals interpret single or double quotes have had some weird results. So I tend to stick with <b>-e</b>, but you do you.
            </p>
            <p>
                Now we have out expression <b>[0-9][a-z][dD]f</b>. What this is saying is:<br>
                -<b>[0-9]</b> in the first position of the string (word) we have anything from the number 0 - 9. So it can be any single digit number.<br>
                -<b>[a-z]</b> in the second position we have any lower case letter in the range a - z. So the whole lower case alphabet.<br>
                -<b>[dD]</b> This says in the third position we can have either a lower or upper case d.<br>
                -<b>f</b> in the last position we have the letter f.<br>
            </p>
            <p>
                So a few strings that would match that search query would be:<br>
                - 0qDf<br>
                - 9zdf<br>
                - 7bdf<br>
            </p>
            <p>
                Wow, that... was a lot and we haven't even done anything with bandit. But now that you have a very basic idea of grep and how it can be a text based super power. We can work on the challenge.
            </p>
            <p>
                Our password is stored in a file <i>data.txt</i> and is next to the word <i>millionth</i>. So using <b>grep</b> we can find that pretty easily. Since grep will match the searched string (word) and print out the line the password is in. So if we do:
            </p>
            <pre id="codeBlocks">
                <code>
                $ grep -e millionth data.txt
                </code> 
            </pre>
            <p>
                We will get one line of output that has the password. Grab that and I will catch you on the 8th floor where grep, regex and everything will get weirder.
            </p>
        </div>


        <button class="accordion">Bandit  8</button>
        <div class="panel">
            <p>Lorem ipsum</p>
        </div>


        <button class="accordion">Bandit  9</button>
        <div class="panel">
            <p>Lorem ipsum</p>
        </div>


        <button class="accordion">Bandit  10</button>
        <div class="panel">
            <p>Lorem ipsum</p>
        </div>
    
    </div>
    <script src="script.js"></script>
</body>
</html>
