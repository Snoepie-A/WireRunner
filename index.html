<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wire Runner</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
    <h1>Welcome to Wire Runner!</h1>
 
        <img src="wirerunner.gif"  id="wireRunner" height="150px"/> 

    <p style="text-align: center;">
        Here you will find your guide to and explanation of Over The Wire challenges. All commands are run from the Linux bash terminal.
    </p>

    <button class="accordion">Bandit  +</button>
    <div class="panel">
        <button class="accordion">Bandit  0</button>
        <div class="panel">

            <p>
                For level 0 of over the wire we will just need to login. The details are given to us. The little dollar sign is a terminal character that means the command is being run as the user you are logged in as. Login using the following:
            </p>

            <pre class="codeBlocks">
                <code>
                $ ssh bandit0@bandit.labs.overthewire.org -p 2220 
                </code> 
            </pre>
            
            <p>
                What does all the above letter soup mean you wonder? Let's break it down!
            </p>

            <p>
                First with <b>ssh</b> we tell the computer. "Hey, you have this thing called <b>S</b>ecure <b>SH</b>ell. I want to use that command."
                <br/><br/>
                Then we say where we want to ssh to. You will see the next part kinda looks like an email? It can be interpreted in the same way. The first part before the <b>@</b> is the user we want to be. In this case bandit0. After the <b>@</b> is the domain we want to be at. In this case: bandit.labs.overthewire.org. Neat! <br/><br/>
                Lastly we have this weird <b>-p 2220</b> thing... what's that about? Long story short this specifies the network port you want to connect to. Web servers use ports to keep their services and communication streams separate.
             </p>
            <p>
                If you have never logged in to over the wire you will be prompted to accept a Key. Huh? What? Keys? <br/><br/>
                Basically what is happening here is. When you encrypt something you and the person you are talking to need to agree on how things will be encrypted. This key is part of the cipher you will need to encrypt things to securely talk to the server you are connecting to. <br/><br/>
                What does all this "The authenticity of host '[bandit.labs.overthewire.org]:2220 ([176.9.9.172]:2220)' can't be established." Mean? Well in the scary world of the internet we have some authorities that can validate that someone is who they say they are. This is just saying these authorities don't have a record for this key or who it belongs to. Rest assured though. You can accept this key. So just say yes.
            </p>
            <p>
                Next we will be prompted for the password to login with. Luckily they give this to you!
            </p>
            <pre class="codeBlocks">
                <code>
                bandit0  
                </code> 
            </pre>
            <p>
                Enter this password and you are now logged in as another user, on another computer, somewhere else completely on earth. That's insane!
            </p>
            <p>
                The next instructions are also given to you this early in the game. The next password is in a file called <b>readme</b> and we use that password to login to the next level. To read it use the <b>cat</b> command.
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat readme 
                </code> 
            </pre>

            <p>
                The <b>cat</b> command just reads some text and prints it out to the terminal for you to read. I still personally like to imagine that the floating cat head from Alice in wonderland is reading it to me.
            </p>
            <p>
                Copy this weird long looking password. Exit your connection session by typing:
            </p>
            <pre class="codeBlocks">
                <code>
                $ exit 
                </code> 
            </pre>
            <p>...into your terminal. And you should be back to your home terminal.</p>
            <p>Sweet! We did it. Now we can go on to the next level. Ready?</p>
        </div>

    
        <button class="accordion">Bandit  1</button>
        <div class="panel">
            <p>
                Now we are at our first challenge. here the password is stored in a file called: <b>-</b>
            </p>
            <p>
                Cool, we read a file last time... just use <cat>cat</cat>? Ah... doesn't work.. what gives?
            </p>
            <p>
                When cat sees the "-" it does not interpret this as a file name, it interprets it as another way to represent stdin (standard input, basically where your computer receives input from, no need to worry about this to much at the moment).
            </p>
            <p>
                Well how do we get around this? We would need to tell cat to interpret this as a file name. To do this we need to use a special character combination in Linux:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ./ 
                </code> 
            </pre>
            <p>
                Well that looks really weird... what does it do? In Linux this is a way to tell a command, or anything almost that "Hey, I want to look for or do this thing in the directory that we currently are." Directories are the same thing as folders in Windows.
            </p>

            <p>
                So to read the password file we would need to:
                <pre class="codeBlocks">
                    <code>
                    $ cat ./- 
                    </code> 
                </pre>
            </p>

            <p>
                Great! That was weird but not too hard. Ready for the next level? Let's go!
            </p>
        </div>


        <button class="accordion">Bandit 2</button>
        <div class="panel">
            <p>
                So our next machine needs us to open a file with spaces in it. Luckily this is super easy. 
            </p>
            <p>
                What makes opening a file with spaces different is that cat does not interpret the space as space character. It thinks you want to open another file. So:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat this file
                </code> 
            </pre>
            <p>
                Would be asking the computer to:<br>
                -cat the file: this<br>
                -cat the file: file<br>
                So the error we will get with this is telling us that the file name we put in to cat does not exist. As all of these treated as separate file names and are thus not valid names of things that we can cat.
            </p>
            <p>
                How do we get around this? There are two ways we can go about this
            </p>
            <p>
                Well we need to tell cat that the string of text we put in is the exact wording. And just as with english. We use quotes! So we need:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat "spaces in this filename"
                </code> 
            </pre>
            <p>
                Basically what this is saying is. Everything in the quotes is the exact words and formatting(spaces included) that I want.
            </p>
            <p>
                Another way we can do this is with back slashes. What these do is they escape the function of the character being fed to the terminal. So by default it would mean "Hey here is a space, so things after this character is considered a new file.". By escaping this meaning we can have the space be what we are use to it being in text files. So it would look like:
            </p>

            <pre class="codeBlocks">
                <code>
                $ cat spaces\ in\ this\ filename
                </code> 
            </pre>
            <p>
                Woah! That looks kinda funky! Do I need to remember how to format this? Luckily not! Linux has this super cool feature called tab complete.
            </p>
            <p>
                What tab complete does is search for files or folders in the directory that you are currently in and try and match the name as best as possible. So try typing:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat sp
                </code> 
            </pre>
            <p> 
                And now press tab. It will complete it all for you! Sweet! 
            </p>
            <p>
                Submitting the command one of these two ways will get you the next password and we are on our way to level 3!
            </p>
        </div>


        <button class="accordion">Bandit  3</button>
        <div class="panel">
            <p>
                Cool. Now we are in level 3. In this level our password is in a hidden file in a folder.
            </p>
            <p>
                First, let's find our folder. How do we do this in the text based terminal Matrix? We use the command: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ ls
                </code> 
            </pre>
            <p>
                Well... what does this do? Simple, it just <b>L</b>i<b>S</b>ts everything in the directory that you are currently in. We will then see a directory named: <i>inhere</i>
            </p>
            <p>
                Well how do we get into "inhere" We use this command:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cd inhere
                </code> 
            </pre>
            <p>
                This means <b>C</b>hange <b>D</b>irectory and is a command you will use so much that you will feel like a CD with only one song on it.
            </p>
            <p>
                New directory, new files and directories to find. <b>ls</b> time! What? Huh? ls didn't work? Or the directory is empty? Did I and over the wire just lie to you?
            </p>
            <p>
                Now we get to hidden files and folders. How do we see those? We use the command:
            </p>
            <pre class="codeBlocks">
                <code>
                $ ls -la
                </code> 
            </pre>
            <p>
                This will list everything in a <b>l</b>ong format (gets you extra juicy details) and will list <b>a</b>ll of the files and directories. These can be spotted with the "." (dot) that the file or directory name starts with. In this case the file with the name "<i>.hidden</i>" .
            </p>
            <p>
                Why the naming convention? Not sure really. Someone just decided that's the way (ah-ha ah-ha) they like it.
            </p>
            <p>
                Anyway you can now just cat the hidden file (be sure to include the period in the name) and you can read the password for the next level.
            </p> 
            <pre class="codeBlocks">
                <code>
                $ cat .hidden
                </code> 
            </pre>

            <p>
                See you in the 4th dimension!
            </p>
        </div>


        <button class="accordion">Bandit  4</button>
        <div class="panel">
            <p>
                The next password is in the only human readable file in the "<i>inhere</i>" directory. What does that mean?
            </p>
            <p>
                Well anything that isn't really data files. That definition should be good enough for now.
                But to see what one looks like, after you <b>cd</b> into the inhere directory. Run an <b>ls</b> so that we can see all the files. let's open the first file. They are all dashed file names. Luckily we have also touched on these before. So run the command: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat ./-file00
                </code> 
            </pre>
            <p>
                What just happened to the terminal? That is a mess! Luckily to clear up this mess all we have to do is well.. clear it. Run this command:
            </p>
            <pre class="codeBlocks">
                <code>
                $ clear
                </code> 
            </pre>
            <p>
                That looks better. Well how do we find the file we want?
            </p>
            <p>
                Linux has this cool command called <b>file</b> we give it the name of a file we want to know the type of and it will tell us what the data in the file tells the program it is. (So if you make a text file, but change the extension to be .png, you won't be fooling file)
            </p>
            
            <p>
                So we gotta run file on all of these until we get the right one? I mean... you can, I won't stop you. Or... we can do this:
            </p>
            
            <pre class="codeBlocks">
                <code>
                $ file ./*
                </code> 
            </pre>
            
            <p>
                So we know what <b>file</b> does... and we know what <b>./</b> means.... what is the asterisk (<b>*</b>) doing? It is a wild card symbol. It is a way to tell the terminal match anything. I don't care what it is or what it is called, it is a match. So *.txt would mean all text files. *.mp3 would be all mp3s.  
            </p>
            <p>
                The above command is just saying use file on all things in this directory. You will see one of the files has a different file type. You can <b>cat</b> this file (remember how to cat things starting with a "-"? If not just scroll up to bandit 1). And we have the password for level 5. See you there!
            </p>
        </div>


        <button class="accordion">Bandit  5</button>
        <div class="panel">
            <p>
                So, we have made it to level 5 and now we get to start putting a lot of things together. In this challenge our file is one of many files in one of many folders, and has quite a few properties.
            </p>
            <p>
                It is human-readable, 1033 bytes in size and not executable. The only one we really care about is the file size. How are we going to find this file without going through each file and directory?
            </p>
            <p>
                Easy, Linux has a <b>find</b> command. Find works by default by starting from the directory you run it in and going down the directory tree. We can learn more about the command and its arguments by using the <b>man</b> command
                <pre class="codeBlocks">
                    <code>
                    $ man find
                    </code> 
                </pre>
                This will open a document that will explain the command and many of its potential uses and options to you. Enough about this though, let's get to finding that file!
            </p>
            <p>
                So we know we can use the <b>find</b> command and we have some details about the properties of the file we want to find, most notably its size. We can use this to narrow down the amount of files it could be. So let's run this from the home directory (not in any subdirectories such as any of the <i>maybehere</i> directories.)
            </p>
            <pre class="codeBlocks">
                <code>
                $ find -size 1033c
                </code> 
            </pre>
            <p>
                So the above command says we want to use find from where we are running the command in the directory tree and down, and we are looking for a file with the <b>size</b> of <b>1033c</b>. The <b>c</b> is to denote bytes.
            </p>
            <p>
                We will get one matching file. Now you can either <b>cd</b> to the directory the file is in, or copy the whole output of find and paste it after cat. So it will look like:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat ./inhere/maybehereXX/XXXX
                </code> 
            </pre>
            <p>
                I am omitting the correct path as not to spoil it.
            </p>
            <p>
                Grab that password and we are on to level 6!
            </p>
        </div>


        <button class="accordion">Bandit  6</button>
        <div class="panel">
            <p>
                This level is pretty much the same thing as the last one. We will use <b>find</b> again. With a few more parameters. Our file has a few properties again. It is <i>somewhere</i> on the server, meaning we would need to search the whole directory tree. It is owned by group 6 (We won't really be using this info). It has a size of 33 bytes.
            </p>
            <p>
                Sweet so from all that info we can do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ find / -size 33c -user bandit7 2>/dev/null
                </code> 
            </pre>
            <p>
                Looks kinda familiar... right? Let's look at what every part of that... incantation means. We have used <b>find</b> so we know what that does. What's the  <b>/</b> doing? Well remember when I said that find works by search from where you are and down the directory tree? Here we are telling find where to start from. The / is a way of declaring the root of the directory tree, so it will search through <i>everything</i>... the whole system. At least everything your user has permission to access. More on that in a bit.
            </p>
            <p>
                <b>size</b> we touched on, this just lets us specify how big the thing we want to find is.
            </p>
            <p>
                <b>user</b> is a new one. Not too hard to guess what it means though. It is just the name of the user that owns the file or directory.
            </p>
            <p>
                Now the weird one. What is this <b>2>/dev/null</b> thing? This is not a part of find. This lets us manipulate the output we will get from find. So remember when I said <i>"At least everything your user has permission to access."</i> When we use find it will tell us when it cannot access a certain directory because it does not have permission, it does this mainly to inform you that, "Hey, I couldn't look through this thing further, I'm just letting you know so that you can decide on what to do about that. Do you wanna give me permission? 'Cause your file might exist there.". This is where we get to the <b>2</b> this is a way to specify stderr (standard error). All outputs that are errors use this instead of stdout (standard out). No need to worry about what these are now. Basically the system just handles how it presents standard output and error output a little different, and we currently care about the errors to clean up our output. So 2 means error output. 
            </p>
            <p>
                Now we have the <b>></b>. This is a redirect. It is what we use to tell output from things where to go if we do not want to use the defaults.
            </p>
            <p>
                Then we have /dev/null . This is a directory path, no? Yes! Exactly we are redirecting it to what is essentially a black hole in Linux. Anything you send here will just vanish into the void.
            </p>
            <p>
                You can run the command without the 2>/dev/null, but that will fill up your screen. Let's run the one that does redirect again to get our less cluttered output.
            </p>
            <p>
                You should now see two results. We could use the <b>-group bandit6</b> flag here as well, but I think this level of "perfect" command is not needed, and we will touch on this more in level 7 and beyond.  You can either cat both or just the one, should be pretty clear by the file name which one it would be. Again you can either <b>cd</b> all the way to the directory that the file is in and <b>cat</b> it there or you can just <b>cat</b> it from where you are specifying the file path like this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat /XXX/XXX/XXX/XXX/xxx.obviousFileName
                </code> 
            </pre>
            <p>
                Again I left out the file path and name so that I don't make it too easy for you. Grab that password and we are on our way to lucky number 7.
            </p>
        </div>


        <button class="accordion">Bandit  7</button>
        <div class="panel">
            <p>
                Lucky number 7. Here we get into the minefield known as <b>grep</b>. Before we continue with that. This is where things  will start getting really weird and there will be multiple ways to do things and find the answer, this will just be what I did that was good enough. So now I want to stress the importance of not looking for a "perfect" answer. Grep and Regex have books written about them, and every language has it's own regex (regular expression) quirks. So again, do not worry about how to get a 100% correct answer that will only get you the password as output. Get something that is close enough, get the password and move on. Serious bit aside. Let's get started. Luckily the grep in this level is still pretty easy.
            </p>
            <p>
                So what is grep and why is it so terrifying? GREP stands for Global Regular Expression Printer. What does this mean? What is a Regular Expression? A regular expression is a string of letters and symbols we can define so that we can match words in a text file. So I can use GREP to find the string of letters "cat" in a file of my choice, and every time I talk about cats (which is a lot), grep will return that instance of the word. Doesn't sound too hard, and that concept isn't. Where grep gets wild is we can use it to search for things that aren't explicit words. I can tell grep something like: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ grep -e [0-9][a-z][dD]f myfile.txt
                </code> 
            </pre>
            <p>
                Yeah.... what? How is that even a thing? What does that even mean? Let's take it piece by piece.
            </p>
            <p>
                First we just have the command <b>grep</b>, which is just asking the terminal to use the command grep in all of its goodness.
            </p>
            <p>
                Next we have <b>-e</b>. This lets grep know that whatever is following is the expression we want to use. The expression can also be put in single or double quotes. so: "expression" or 'expression', but I have seen instances where how different terminals interpret single or double quotes have had some weird results. So I tend to stick with <b>-e</b>, but you do you.
            </p>
            <p>
                Now we have out expression <b>[0-9][a-z][dD]f</b>. What this is saying is:<br>
                -<b>[0-9]</b> in the first position of the string (word) we have anything from the number 0 - 9. So it can be any single digit number.<br>
                -<b>[a-z]</b> in the second position we have any lower case letter in the range a - z. So the whole lower case alphabet.<br>
                -<b>[dD]</b> This says in the third position we can have either a lower or upper case d.<br>
                -<b>f</b> in the last position we have the letter f.<br>
            </p>
            <p>
                So a few strings that would match that search query would be:<br>
                - 0qDf<br>
                - 9zdf<br>
                - 7bdf<br>
            </p>
            <p>
                Wow, that... was a lot and we haven't even done anything with bandit. But now that you have a very basic idea of grep and how it can be a text based super power. We can work on the challenge.
            </p>
            <p>
                Our password is stored in a file <i>data.txt</i> and is next to the word <i>millionth</i>. So using <b>grep</b> we can find that pretty easily. Since grep will match the searched string (word) and print out the line the password is in. So if we do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ grep -e millionth data.txt
                </code> 
            </pre>
            <p>
                We will get one line of output that has the password. Grab that and I will catch you on the 8th floor where grep, regex and everything will get weirder.
            </p>
        </div>


        <button class="accordion">Bandit  8</button>
        <div class="panel">
            <p>
                In this challenge our password is stored in <i>data.txt</i> and is the only line that appears only once. So let's <b>cat</b> that file and see what we have to work with.
            </p>
            <p>
                Yikes. That looks messy. How can we clean it up so that we get what we want?
            </p>
            <p>
                We can do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat data.txt | sort | uniq -c
                </code> 
            </pre>
            <p>
                Well, some of that looks familiar some of it does not. Let's take it step by step.
            </p>
            <p>
                <b>cat</b> just reads the file we give it as input.
            </p>
            <p>
                Then we have this thing: <b>|</b>. What's this? This is a pipe. What it does is take the output from the command on the left of it and feeds it as input to the command on the right. So instead of cat's output going to the screen we send it to the next command <b>sort</b>.
            </p>
            <p>
                So now we can talk about <b>sort</b>. What <b>sort</b> is doing here is reading the whole document. Looking for lines that are exactly the same and rearranges them so that they are one after another. 
            </p>
            <p>
                Then we pipe it again to the next command <b>uniq -c</b>. What uniq does is look for lines that are exactly the same and then omits all but one of them. Important here is that <b>uniq</b> has to be run after <b>sort</b> because uniq will only omit duplicate lines that occur after each other. Lastly we have <b>-c</b>, All this does is show a count for each line, how many times it occurred in the document. 
            </p>
            <p>
                Look for the only string that occurs just once based on the count on the left. Grab that and I will meet you in level 9.
            </p>
        </div>


        <button class="accordion">Bandit  9</button>
        <div class="panel">
            <p>
                This time our password is in the <i>data.txt</i> and is one of the few human-readable strings, preceded by several ‘=’ characters.
            </p>
            <p>
                Cool so just: grep -e == data.txt (two == at least since we know it is multiple equals signs.)
            </p>
            <p>
                Uhm... what? What does "Binary file data.txt matches" mean? From the grep man pages we can see "Normally, if the first few bytes of a file indicate that the file contains binary data, grep outputs only a message saying that the file matches the pattern" Since our file starts with binary we get this output. So what do we do?
            </p>
            <p>
                We can do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ grep -a -e == data.txt
                </code> 
            </pre>
            <p>
                We should know what most of that does. Just the <b>-a</b> is new. This will let grep treat the binary as if it is text. But this output is very messy. You can still see the password, grab it and go or.... We could do this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ strings data.txt | grep -e ==
                </code> 
            </pre>
            <p>
                The only new command here is <b>strings</b> and basically all it does is print only all the text characters in a document. So none of the binary noise.
            </p>
            <p>
                There are many lines of output here. Only one of them has the same format as the passwords we have been using. Copy it and I will catch you in our first double digit challenge! 
            </p>
        </div>


        <button class="accordion">Bandit  10</button>
        <div class="panel">
            <p>
                I am going to be honest with you here. This level feels like a downtick in difficulty. The password is stored in the <i>data.txt</i> file and the whole file is base64 encoded. What is base64? In short and very basically put, it is a way for us to represent binary data to an ASCII string.
            </p>
            <p>
                Base64 is so popular that Linux has a built in command for working with it: <b>base64</b>. Reading through the man page will get us more info on what we can do with it. But we really just care about <b>--decode</b>. So:
            </p>
            <pre class="codeBlocks">
                <code>
                $ base64 --decode data.txt
                </code> 
            </pre>
            <p>
                Here we are saying we want to use base64, we want to use the decode functionality and we want to use it on the data.txt file. Pretty simple.
            </p>
            <p>
                Grab that password and I will see you in the next level.
            </p>
        </div>

        <button class="accordion">Bandit  11</button>
        <div class="panel">
            <p>
                Here is another one where we can kind of be lazy. Or at least, there are very easy ways of doing this.</p>
            <p>
                Our password is stored in the <i>data.txt</i> file and all upper and lowercase letters have been rotated 13 positions. Basically the alphabet now starts from n and goes all the way around back to m as the last letter. We are replacing the letters of the alphabet with the 13th letter after it in the alphabet.
            </p>
            <p>
                What makes this pretty simple is there are many decoders for this online. So a quick Google search for a ROT-13 decoder will get us a webpage where we can paste the text in and get our answer. Do that, get the answer and we can go to level 12.
            </p>
            <p>
                If you really want to know how to do something like this in the terminal:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat data.txt | tr [a-z] [n-za-m] |tr [A-Z] [N-ZA-M]
                </code> 
            </pre>
            <p>
                Let's break down what this is saying:
            </p>
            <p>
                <b>cat</b> will read the file and push it through to <b>tr</b> command (translate).
            </p>
            <p>
                Then we say: hey translate command (tr). I want to use this character set <b>[a-z]</b> and I want you to shift it so that it would work like <b>[n-za-m]</b> (the 14th letter of the alphabet to the 26th and then the 1st to the 13th), all only in lower case.
            </p>
            <p>
                All of this is the: <b>tr [a-z] [n-za-m]</b>
            </p>
            <p>
                We then take what that output would be and push it through to translate again, and do the same thing, but with upper case characters.That is the:
                <b>tr [A-Z] [N-ZA-M]</b>. After which you will have your answer.This is also a very verbose way of going through it, but it can help keep your logic and readability clear.
            </p>
            <p>
                A much more condensed version of the command would be:
            </p>
            <pre class="codeBlocks">
                <code>
                    $ cat data.txt | tr [a-zA-Z] [n-za-mN-ZA-M]
                </code> 
            </pre>
            <p>
                Which does the same thing, we just give it both data sets and translation sets at once. Get the password and I will see you in level 12.
            </p>
        </div>

        <button class="accordion">Bandit  12</button>
        <div class="panel">
            <p>
                Now, this one... is a jump in difficulty. It also just has a lot for us to do, so it will take a minute. 
            </p>
            <p>
                So first they tell us. To do this box we should create a directory under /tmp in which you can work using mkdir. Why? Well because the file we are working with is a hex dump and has then been compressed multiple times. So using a copy of the file just seems like a really good idea since we might break or corrupt something.
            </p>
            <p>
                What is a hex dump? A hex dump is a snapshot of what was in the computers memory. So in this case, a memory dump of what was the compressed file. 
            </p>
            <p>
                But first that copy... how will we do that? Well with this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mkdir /tmp/wireRunner
                </code> 
            </pre>
            <p>
                The <b>mkdir</b> means <i>make directory</i> and the <b>/tmp/wireRunner</b> specifies the absolute path, from root, of where we want the file to be made as well as its name. If you do not do it this way, you will probably just get a permission denied error from the bandit box. Just replace wireRunner with your name. 
            </p>
            <p>
                Then we copy the file with the <b>cp</b> command. We specify first what we want to copy and then where we want to copy it to:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cp data.txt /tmp/wireRunner
                </code> 
            </pre>

            <p>
                Now we just <b>cd</b> to <b>/tmp/wireRunner</b> and we can get started!
            </p>
            <p>
                Cool, so how can we work with and interact with this hex file? Linux has a command <b>xxd</b>. Which can be used to create or reverse hex dumps. So we need to do:
            </p>
            <pre class="codeBlocks">
                <code>
                $ cat data.txt | xxd -r > data
                </code> 
            </pre>
            <p>
                So by now, some of that should make sense. <b>cat</b> reads the file and we pipe it to our <b>xxd</b> command. The <b>-r</b> tells xxd to reverse the hex dump and then lastly we redirect its output to a new file called <i>data</i> with <b>> data</b>.
            </p>
            <p>
                Now we run <b>file</b> on the <i>data</i> file we got as output and it will tell us that this file is gzip compressed data. Gzip files have an extension of <b>.gz</b>. So we can rename the file and decompress it. How do we rename?
                With the <b>mv</b> command. This command is used to move files, but can also be used to rename them.
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data data.gz
                </code> 
            </pre>
            <p>
                The above command is saying move (<b>mv</b>) the <i>data</i> file in our current directory to our current directory and then call it <i>data.gz</i>. Weird thing to wrap your head around I know. You are just moving the file to the exact same place and then just renaming it.
            </p>
            <p>
                Now that it has the .gz extension we can interact with it with the <b>gzip</b> command and use its <b>-d</b> (decompress) flag to get the data decompressed.
            </p>
            <pre class="codeBlocks">
                <code>
                $ gzip -d data.gz
                </code> 
            </pre>
            <p>
                Now we have a data file again, we can see this with <b>ls</b>. So lets <b>file</b> it again to see what we are working with. Ahh.. a bzip2 file. These have the extension of <b>.bz</b>. We will need to rename it and then decompress it. This will be the theme until the file is ascii text again. Yay?
            </p>
            <p>
                So move to rename:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data data.bz
                </code> 
            </pre>
            <p>
                Now that we have the <b>.bz</b> how do we unzip it? If we look at the man page for bzip2, we can see that there is a bunzip2. Lets try that:
            </p>
            <pre class="codeBlocks">
                <code>
                $ bunzip2 data.bz
                </code> 
            </pre>
            <p>
                We have a data file again. <b>file</b> time. It is a gzip again. So move to rename with the <b>mv</b> command and give it the .gz extension. Then decompress with the <b>gzip -d</b>. Another data file. Run <b>file</b> on it and we have a... Oh? What is a posix tar archive? Just another compression standard, no need to worry about it too much. What is its extension? Just <b>.tar</b>
            </p>
            <p>
                So move to rename:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data data.tar
                </code> 
            </pre>
            <p>
                Now we need to decompress it again:
            </p>
            <pre class="codeBlocks">
                <code>
                $ tar -xf data.tar
                </code> 
            </pre>
            <p>
                <b>tar</b> uses the tar command and the <b>-xf</b> extracts the file archive.
            </p>
            <p>
                Now if we <b>ls</b> we have a.. <i>data5.bin</i>? The <i>data.tar</i> is also still there. I mean ok.. sure. Lets file the data5.bin. Another .tar? Yep. So move to rename:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mv data5.bin data.tar
                </code> 
            </pre>
            <p>
                What? We are renaming it with a name that already exists? Yep. In Linux this will not give you an error. It will just over write the file and since we are done with the previous <i>data.tar</i> we can do this.
            </p>
            <p>Another <b>tar -xf data.tar</b> time.</p>
            <p>
                This time we get <i>data6.bin</i>. Man this has been going on a while.... I promise we are almost done. <b>file</b> <i>data6.bin</i> and we have another bzip2. Rename and decompress time again. <b>.bz</b> extension and the bunzip2 command time. 
            </p>
            <p>
                A new data file. <b>file</b> command. Another tar. Rename to a <b>.tar</b> and then <b>tar -xf</b> time
            </p>
            <p>
                Now we have <i>data8.bin</i> was a gzip file. You guessed it. Rename to <b>.gz</b> and <b>gzip -d</b>.
            </p>
            <p>
                <b>file</b> our data file again and.... oh my.... It is actually an ASCII file this time. We did it! We got through all this and now we finally have our password! Grab it and we are on to level 13 that shouldn't be this tedious again.
            </p>
        </div>

        <button class="accordion">Bandit 13</button>
        <div class="panel">
            <p>
                So in this level we know what file the password is kept in. But it can only be read by user <i>Bandit 14</i>. Well how can we read it as user 13? We get a private SSH Key that we can use to log in to the bandit14 user. 
            </p>
            <p>
                We can use <b>ls</b> to see the file is in our home directory. Awesome! How do we use it?
            </p>
            <p>
                Like this:
            </p> 
            <pre class="codeBlocks">
                <code>
                $ ssh bandit14@localhost -i sshkey.private
                </code> 
            </pre>
            <p>
                Sweet, most of that looks familiar by now. Just two new things.
            </p>
            <p>
                <b>localhost</b> is just a way to refer to the system you are currently working on.
            </p>
            <p>
                <b>-i</b> lets you choose a file that validates your identity.
            </p>
            <p>
                Awesome now we just need to get to that file in <i>/etc/bandit_pass</i> and then <b>cat</b> the <i>bandit14</i> file and we have the password!
            </p>
            <p>
                See you in level 14!
            </p>
        </div>
    
        <button class="accordion">Bandit 14</button>
        <div class="panel">
            <p>
                Welcome to level 14. You have 2 options on how to proceed. If you are still logged on to bandit14 from the last level. Great! We can just continue. If not just ssh back into it and we can get going.
            </p>
            <p>
                So here we are told we can get the password for <i>bandit15</i> by submitting the password for <i>bandit14</i> to port <i>30000</i> of the localhost.
            </p>
            <p>
                That is a mouthful. Basically it is saying that we need to send information to a server that is set up on our localhost. This is doable with a command <b>nc</b> (netcat) to connect locally. netcat is a unix utility that sends and receives data across network connections. Including ones on our local machine. So we just have to give the password for  level 14 to this port on our local machine and it will return the password for level 15.  
            </p>
            <p>
                This should do the trick:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "4wcYUJFw0k0XLShlDzztnTBHiqxU3b3e" | nc localhost 30000
                </code> 
            </pre>
            <p>
                <b>echo</b> literally just copies back as output what you gave it as input. The pipe symbol we have worked with. It takes output from the left and feeds it as input to the right. Then <b>nc</b> lets us use the network connection on <i>localhost</i> on port <i>30000</i>. You will then get the password for level 15 and we are on our way again!
            </p>
        </div>

        <button class="accordion">Bandit 15</button>
        <div class="panel">
            <p>
                So things are getting harder and we might tend to start using commands or technologies that you can spend a lot of time on. We will only be touching on the very basic for what we need for the solution. If you ever feel like you want to spend more time investigating these technologies, please do. Just know that you can spend weeks and still not know everything you want. Google is your friend here. 
            </p>
            <p>
                Why the speech? We are going to use <b>openSSL</b>. This lets us use TLS protocols for secure connections and communications in computer networks. TLS is a set of cryptographic protocols. Yes these descriptions are pretty vague. I believe it is all we need. It gives us enough to have utility. Basically openSSL is a technology that lets us encrypt our connections. You know when your web browser says httpS vs just http? This is what provides the S (secure). 
            </p>
            <p>
                Our challenge states we can get our password for <i>bandit16</i> by submitting the <i>password</i> for <i>bandit15</i> to port <i>30001</i> to the local machine with ssl encryption.
            </p>
            <p>
                Mouthful again. Basically we just need to use an ssl connection (<b>openssl</b> can do this) to connect to a different port on the machine we are currently using and submit the password of the current level as input.
            </p>
            <p>
                How?
            </p>
            <p>
                Like this:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "BfMYroe26WYalil77FoDi9qh59eK5xNr" | openssl s_client -connect localhost:30001 -ign_eof
                </code> 
            </pre>
            <p>
                Sweet, the only really new thing here is the <b>openssl</b> stuff. The echo and pipe we have touched on in the last challenge. 
            </p>
            <p>
                <b>openssl</b> just says we want to use the openssl command
            </p>
            <p>
                <b>s_client</b> creates a generic ssl/tls client that we can use to connect to a server that is running ssl/tls to communicate. This is what allows us to connect to the secure server. This is only used for testing however.
            </p>
            <p>
                <b>-connect localhost:30001</b>. This tells openssl where we want to connect to and on which port.
            </p>
            <p>
                <b>-ign_eof</b> all this is doing is keeps the communication stream open after it has been established. Why do we need this? When setting up the connection we get a whole bunch of info back from the ssl/tls server. After this information is received the connection appears to close before we can send our information from echo so that we can get the password for bandit16. As a side note you can omit some of the extra output with <b>-quiet</b>. You will just lessen the amount of output. The password will still appear at the bottom of your output.
            </p>
            <p>
                Grab that password and get ready for more weirdness.
            </p>
        </div>

        <button class="accordion">Bandit 16</button>
        <div class="panel">
            <p>
                Not gonna lie, another funny one. It combines some things we have done before, but also requires us to use new tools. Most notably <b>nmap</b>. But I am getting ahead of myself. Here our password can be retrieved by submitting the password of the current level to a ssl server on a port in the range 31000 to 32000 on our local machine. Only one of these will give us the password. How can we narrow this down? 
            </p>
            <p>
                Meet one of your best friends in the world of networking, info-sec and administration. <b>nmap</b>. It is a network mapper. You will use it to see which IPs are up, what ports are open and what services they run. It is honestly worth investing time into learning this beautiful tool. We will not be going that in-depth with it here though. So what we want with nmap is:
            </p>
            <pre class="codeBlocks">
                <code>
                $ nmap -sV localhost -p31000-32000 | grep -e ssl
                </code> 
            </pre>
            <p>
                So that is just saying we want to use <b>nmap</b>. With <b>-sV</b> we are telling nmap to do a detailed scan on the ports and what services they may be running. Then we say the device we want to scan, in this case <b>localhost</b> (which we know means the machine we are working on). And then the ports we want to scan. This is declared with the <b>-p31000-32000</b>. This will take a moment to scan. So get up, get some water.. maybe a good stretch? It is good for you.
            </p>
            <p>
                We then pipe the output to <b>grep</b> and only look for the pattern ssl with: <b>grep -e ssl</b>. We know we are looking for an ssl service and nmap will report this back to us if it is running on a port. grep is just removing a lot of noise from the nmap output. If you have the time, or you just want to, you can run this without grep and look at everything you get. This is why grep is so nice and so powerful. 
            </p>
            <p>
                Great now with just the two possible ports our job has gotten a lot easier. One of these is running an ssl/echo service and the other is an ssl/unknown. I'm gonna go ahead and guess that the ssl/echo is just gonna send back what we send it. So let us try the other port:
            </p>
            <pre class="codeBlocks">
                <code>
                $ echo "cluFn7wTiGryunymYOu4RcffSxQluehd" | openssl s_client -connect localhost:31790 -ign_eof
                </code> 
            </pre>
            <p>
                Cool. Here we echo the password into the connection. We use openssl with s_client to say we want to be the client side of things. (Remember this from the last level?). We tell openssl where we want to connect to. In this case the port we found with nmap (<b>31790</b>) and we use our <b>-ign_epf</b> to keep that connection open... 
            </p>
            <p>
                Ok what gives? We don't get a password. Should we try the other port? Nope. We get the RSA private key. A few levels ago we use a private key to connect to another user on the same machine. So let us save this private key in a file so we can use it to authenticate as user bandit17.
            </p>
            <p>
                Copy everything above and below the dashed lines. It is a lot yes. Now where to save it? If you recall when we worked on the decompression issue we cannot just create files anywhere on bandit. We can only use <b>/tmp</b>.
            </p>
            <p>
                Make another folder in tmp with:
            </p>
            <pre class="codeBlocks">
                <code>
                $ mkdir /tmp/rsaWireRunner
                </code> 
            </pre>
            <p>
                All of that should make sense at this point. But as a quick reminder. <b>mkdir</b> means make directory. Then we give it the path as well as the directory we want to make with <b>/tmp/rsaWireRunner</b>. Just use your own directory name. (Not rsaWireRunner). 
            </p>
            <p>
                Cool the directory exists. Now we cd to it. Once in the directory we can create the file we want. We can do this with:
            </p>
            <pre class="codeBlocks">
                <code>
                $ vim rsaKey
                </code> 
            </pre>
            <p>
                This will create the file named <b>rsaKey</b> and open it in the vim editor. If you have never used vim, it is a weird text editor, but a great one. To start being able to type something or paste something, first press <b>i</b> to insert. Now you can paste the copied key with <b>right click and paste</b> or with <b>ctrl+shift+v</b>. Sweet. Now to save and quit. First press <b>Esc</b> to exit insert mode. Then press <b>:</b> so that you can enter new commands. Then you enter <b>wq</b> (this will appear at the bottom left of your screen after the colon).
            </p>
            <p>
                And you are out of there with the file you need. 
            </p>
            <p>
                Now we need to use this to authenticate ourself as bandit17. However... there is an issue if you try it as is. This key file is too accessible to users on this device. The <b>ssh</b> command will pick up on this and tell you it is ignoring the file. So we need to change it so that the file is more private and ssh can be satisfied. So we use:
            </p>
            <pre class="codeBlocks">
                <code>
                $ chmod 400 rsaKey
                </code> 
            </pre>
            <p>
                What is this? In short we use <b>chmod</b> to change file permissions. The <b>400</b> means only root users can read and execute the file (this will keep ssh happy) and <b>rsaKey</b> is the file we want to change the permissions of. Sweet now we can: 
            </p>
            <pre class="codeBlocks">
                <code>
                $ ssh -i rsaKey bandit17@localhost
                </code> 
            </pre>
            <p>
                Sweet. We are finally in bandit17. You can stay here and move on to bandit 18. Or you can take a stretch and water break and come back. In that case we are going to want to save the password for bandit 17. We can find it here:
            </p>
            
            <pre class="codeBlocks">
                <code>
                $ cat /etc/bandit_pass/bandit17
                </code> 
            </pre>
            <p>
                Save that somewhere and we are on our way. 
            </p>
        </div>
    </div>
    <script src="script.js"></script>
</body>
</html>